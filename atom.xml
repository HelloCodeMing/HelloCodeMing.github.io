<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hello Code]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://wanghuanming.com/"/>
  <updated>2016-12-11T05:32:33.000Z</updated>
  <id>http://wanghuanming.com/</id>
  
  <author>
    <name><![CDATA[王欢明]]></name>
    <email><![CDATA[huanmingwong@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MIT6.824 labraft实现]]></title>
    <link href="http://wanghuanming.com/2016/12/raft-implementation/"/>
    <id>http://wanghuanming.com/2016/12/raft-implementation/</id>
    <published>2016-12-08T13:36:13.000Z</published>
    <updated>2016-12-11T05:32:33.000Z</updated>
    <content type="html"><![CDATA[<p>MIT6.824 是MIT的 Distributed System 课程，从RPC开始讲起，到主从备份，容错，再到分布式事务，分布式一致性，介绍了分布式系统各方面的内容。这门课程还包含一些实验，lab1是MapReduce实验，实现一个简单MapReduce框架，最终要能够运行WordCount、InvertedIndex这样经典的MapReduce程序；lab2及之后的lab则围绕着分布式存储这一块，从Raft开始，实现一个具备选主和日志复制功能的Raft（不包含日志压缩和快照），接着再基于Raft实现一个多副本的KV存储，以及进一步实现分片功能。</p>
<p>本文主要记录lab raft 的实现，以及对于Raft 的一些理解。课程实验本身提供了一些基础的代码框架，包括RPC的实现，以及单元测试代码，所以我们基本只要实现raft的核心部分代码就可以了，并且按照TDD的方式，可以从简至繁，逐步实现Raft的各个部分。</p>
<p>由于笔者接触分布式系统的时间还比较短，因此此文可能存在一些毗漏，欢迎读者指出纠正。</p>
<h2 id="Raft">Raft</h2><p>Raft 协议可以视为由选主和主从复制两部分组成的协议，协议开始选出一个strong leader，其他的成为follower，接下来所有命令则提交到leader，由leader复制给follower。</p>
<p>Raft是基于Replicated State Machine 模型：对于多个状态机，如果初始状态一致，输入一致，那么最终状态就会一致。那么，对于数据库来说，到底复制什么呢？一种方式，是把数据库当作状态机，把对数据库的操作当作状态机的输入，也就是“The log hold the truth, database is just an optimization”，只要记录所有的操作日志，就能把数据库恢复到任何状态。对于这种方式，client 首先向 leader 提交一个 “put(“hello”, “world”)”这样的命令，Raft首先把这条命令复制到多个副本，等待majority接受之后，这条命令就可以commit了。commit之后的命令，就可以apply到状态机了，也就是说可以在单机的存储引擎中执行“put(“hello”, “world”)”这条命令了。也就是说，一个命令需要经过 submit, commit, apply 这三个过程才能真正写到数据库。</p>
<p>那么除此之外有没有其他的方式呢，在我看来应该是有的。Raft的log可以当作数据库的REDO log，那么apply这个操作显然就应该交由数据库来处理，而不是raft来apply。再者，log本身是不是也可以作为数据呢，一定要apply到状态机吗？</p>
<h2 id="Raft的实现">Raft的实现</h2><p>Raft能够流行开来，很重要的一个原因就是易于理解，容易实现。基本只要按照Figure2，就能实现一个具备基本功能的raft，不过显然对于工业级使用来说，这样的实现在性能上还是比较差的，同时也会有一些corner case 能够让raft挂掉。不过暂且不考虑这些，我们先来分析一下如何按照Figure2实现raft。</p>
<h3 id="State">State</h3><p>首先是Raft需要维护的状态。需要持久化的状态有三个，currentTerm, votedFor, log[]。currentTerm表示当前的term，votedFor表示投以选票的peer，这两个状态之所以需要进行持久化，是为了保证在重启之后，不会发生重复投票的情况，即“在一个term只给一个candidate投票”，这点是leader election的基本保证，否则就会发生多个leader 的情况。而votedFor还有一点需要注意，它不等价于当前term的leader，不要因为发现了leader就修改votedFor。另一个需要持久化的状态就是log，这个无需赘述。</p>
<p>接下来是所有server都需要维护的非持久化状态: commitIndex, lastApplied。这两个状态是为了实现日志复制。commitIndex指的是当前commit的日志，而lastApplied则是已经apply的日志。这也是前面所说的，submit -&gt; commit -&gt; apply。submitIndex 隐式包含在log[] 中，也就是最后一个log entry。</p>
<p>最后是leader需要维护的状态: nextIndex[], matchIndex[]。matchIndex是成功复制到peer的日志index，这里的成功定义为：appendEntries RPC返回成功。也就是说不管这个log 有没有成功复制到其他的peer，或者有没有commit。按理说每次复制日志的时候，只要把matchIndex后面的日志复制过去就好了，为什么还需要nextIndex呢？主要是为了处理log mismatch 的情况，matchIndex之前的日志还是可能mismatch的，发生这种情况的话，要回退nextIndex，重新尝试。</p>
<h3 id="RPC">RPC</h3><p>Raft主要有两个RPC：AppendEntries和RequestVote。至于InstallSnapshot则算是锦上添花。</p>
<p>AppendEntries用作日志复制和心跳。参数包括term, leaderId, prevLogIndex, prevLogTerm, entries[], leaderCommit，返回值有term, success。term和leaderId是sender的term和id；prevLogIndex, prevLogTerm, entries[]则是日志，prev这个参数一来为了保证Log Matching Safety，二来也是为了保证AppendEntries的幂等。还有一个很重要的参数是leaderCommit，表示leader 的commitIndex，用来进行two phase commit中的commit阶段。</p>
<p>对于AppendEntries的处理：</p>
<ul>
<li>如果term &lt; currentTerm ，返回false。（这个leader已经过期）</li>
<li>如果prevLog不匹配，返回false。（Log Matching Property)</li>
<li>把entries追加到日志的prevLogIndex后面，如果存在冲突，直接覆盖掉</li>
<li>如果leaderCommit &gt; commitIndex，commitIndex = min(leaderCommit, indexOfLastLogEntry)。（commit log）</li>
</ul>
<p>代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rf *Raft) AppendEntries(args AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">	rf.ruleForAll(args.LeaderId, args.Term)</span><br><span class="line">	<span class="keyword">if</span> args.Term &gt;= rf.currentTerm &#123;</span><br><span class="line">		rf.heartBeatCh &lt;- args</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.Unlock()</span><br><span class="line">	term := rf.currentTerm</span><br><span class="line">	logOk := <span class="built_in">len</span>(rf.log) &gt; args.PrevLogIndex &amp;&amp; args.PrevLogTerm == rf.log[args.PrevLogIndex].Term</span><br><span class="line"></span><br><span class="line">	reply.Term = term</span><br><span class="line">	<span class="keyword">if</span> args.Term &lt; term || !logOk &#123;</span><br><span class="line">		reply.Success = <span class="constant">false</span></span><br><span class="line">		<span class="keyword">if</span> args.Term &lt; term &#123;</span><br><span class="line">			rf.logInfo(<span class="string">"Reject AppendEntries, for TermMismatch: %d &lt; %d"</span>, args.Term, term)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !logOk &#123;</span><br><span class="line">			rf.logInfo(<span class="string">"Reject AppendEntries, for LogMisMatch: (%d, %d) not exists"</span>, args.PrevLogIndex, args.PrevLogTerm)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reply.Success = <span class="constant">true</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			rf.log = rf.log[:args.PrevLogIndex + <span class="number">1</span>]</span><br><span class="line">			rf.log = <span class="built_in">append</span>(rf.log, args.Entries...)</span><br><span class="line">			rf.persist()</span><br><span class="line">			rf.logInfo(<span class="string">"AppendEntries successfully: %v"</span>, args.Entries)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &amp;&amp; <span class="built_in">len</span>(rf.log) - <span class="number">1</span> &gt; rf.commitIndex &#123;</span><br><span class="line">			rf.commitIndex = <span class="typename">int</span>(math.Min(<span class="typename">float64</span>(args.LeaderCommit), <span class="typename">float64</span>(<span class="built_in">len</span>(rf.log) - <span class="number">1</span>)))</span><br><span class="line">			rf.logInfo(<span class="string">"Follower update commitIndex: commitIndex: %d"</span>, rf.commitIndex)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个RPC是RequestVote，用于选主。参数包括term, candidateId, lastLogIndex, lastLogTerm, 返回值包括term, voteGranted。term和candidateId还是用于标识一个candidate，而lastLog是为了保证section5.4.1 说的Election restriction，新选出的leader需要包含所有已经提交的日志，那么只要它的日志和其他的一样新，那么它就一定满足这个条件。</p>
<p>所以处理这个RPC时：</p>
<ul>
<li>如果term &lt; currentTerm，返回false</li>
<li>如果votedFor为空，或者就是candidateId，并且lastLog和自己的一样新，就投以选票。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rf *Raft) RequestVote(args RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">	rf.ruleForAll(args.CandidateID, args.Term)</span><br><span class="line"></span><br><span class="line">	rf.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.Unlock()</span><br><span class="line">	voteFor := rf.votedFor</span><br><span class="line">	voteForOk := voteFor == -<span class="number">1</span> || voteFor == args.CandidateID</span><br><span class="line">	lastEntry := rf.log[<span class="built_in">len</span>(rf.log) - <span class="number">1</span>]</span><br><span class="line">	logOk := args.LastLogTerm &gt; lastEntry.Term ||</span><br><span class="line">		(args.LastLogTerm == lastEntry.Term &amp;&amp; args.LastLogIndex &gt;= <span class="built_in">len</span>(rf.log) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> args.Term &gt;= rf.currentTerm &amp;&amp; voteForOk &amp;&amp; logOk &#123;</span><br><span class="line">		rf.beFollower(args.CandidateID, args.Term)</span><br><span class="line">		reply.VoteGranted = <span class="constant">true</span></span><br><span class="line">		reply.Term = rf.currentTerm</span><br><span class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">			rf.beFollowerCh &lt;- follower</span><br><span class="line">		&#125;()</span><br><span class="line">		rf.logInfo(<span class="string">"GrantVote to candidate&lt;%d,%d&gt;"</span>, args.CandidateID, args.Term)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reply.VoteGranted = <span class="constant">false</span></span><br><span class="line">		reply.Term = rf.currentTerm</span><br><span class="line">		<span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">			rf.logInfo(<span class="string">"Not grant vote to &lt;%d,%d&gt;, because term %d &lt; %d"</span>, args.Term, rf.currentTerm)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !voteForOk &#123;</span><br><span class="line">			rf.logInfo(<span class="string">"Not grant vote to &lt;%d,%d&gt;, because votedFor: %d"</span>, args.CandidateID, args.Term, voteFor)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !logOk &#123;</span><br><span class="line">			rf.logInfo(<span class="string">"Not grant vote to &lt;%d,%d&gt;, because logMismatch: %v"</span>, args.CandidateID, args.Term, rf.log)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Server">Server</h3><h4 id="All_Servers">All Servers</h4><p>对于所有server有一些通用的规则。如果commitIndex &gt; lastApplied，就把lastApplied后面的日志apply到SM。如果RPC中的term大于当前term，说明当前节点已经过期，需要更新currentTerm，并且直接变成follower。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rf *Raft) ruleForAll(candidate <span class="typename">int</span>, term <span class="typename">int</span>) &#123;</span><br><span class="line">	<span class="comment">// Apply command need to be serial!</span></span><br><span class="line">	rf.Lock()</span><br><span class="line">	old := rf.lastApplied</span><br><span class="line">	<span class="keyword">for</span> rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">		rf.lastApplied++</span><br><span class="line">		msg := ApplyMsg&#123;Index: rf.lastApplied, Command: rf.log[rf.lastApplied].Command&#125;</span><br><span class="line">		rf.applyCh &lt;- msg</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rf.lastApplied &gt; old &#123;</span><br><span class="line">		rf.logInfo(<span class="string">"Applyed commands until index=%d"</span>, rf.lastApplied)</span><br><span class="line">	&#125;</span><br><span class="line">	rf.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// exists a new term</span></span><br><span class="line">	rf.Lock()</span><br><span class="line">	<span class="keyword">if</span> term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.logInfo(<span class="string">"RuleForAll: find new term&lt;%d,%d&gt;, become follower"</span>, candidate, term)</span><br><span class="line">		rf.beFollower(-<span class="number">1</span>, term)</span><br><span class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() &#123;</span><br><span class="line">			rf.beFollowerCh &lt;- follower</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	rf.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Follower">Follower</h4><p>Follower需要响应AppendEntries以及RequestVote RPC，并且维护一个 election timeout，如果没有收到心跳，需要进入candidate状态。相对来说比较简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rf *Raft) doFollower() &#123;</span><br><span class="line">	rf.logInfo(<span class="string">"Become follower"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(electionTO()):</span><br><span class="line">			rf.Lock()</span><br><span class="line">			rf.role = candidate</span><br><span class="line">			rf.votedFor = -<span class="number">1</span></span><br><span class="line">			rf.persist()</span><br><span class="line">			rf.Unlock()</span><br><span class="line">			rf.logInfo(<span class="string">"Follower lose heartbeat, become candidate"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.heartBeatCh:</span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.beFollowerCh:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Candidate">Candidate</h4><p>进入Candidate状态需要<strong>不断</strong>发起选举，当然，为了避免互相竞争的活锁情况，每次选举的时间也是有间隔的。</p>
<p>对于一次选举，首先增加currentTerm, votedFor改成自己，通过RequestVote向其它peer发起投票。如果收到majority的投票，变成leader（不需要等待所有RPC返回）；如果收到新的Leader的AppendEntries，变成follower；如果超时，进入下一轮选举。第二条规则可能和Rule For All那边有一些重叠，我们需要谨慎处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rf *Raft) doCandidate() &#123;</span><br><span class="line">	rf.logInfo(<span class="string">"Start leader election"</span>)</span><br><span class="line">	<span class="keyword">defer</span> rf.logInfo(<span class="string">"Quit leader election"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// increase term</span></span><br><span class="line">		rf.Lock()</span><br><span class="line">		rf.votedFor = rf.me</span><br><span class="line">		rf.currentTerm++</span><br><span class="line">		rf.persist()</span><br><span class="line">		rf.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// request votes</span></span><br><span class="line">		votedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line">		quitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line">		<span class="keyword">go</span> rf.requestingVote(votedCh, quitCh)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. voted by majority: succeed then quit</span></span><br><span class="line">		<span class="comment">// 2. find a new leader: become a follower and quit.</span></span><br><span class="line">		<span class="comment">// 3. timeout, enter next election</span></span><br><span class="line">		start := time.Now()</span><br><span class="line">		election := electionTO()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(election):</span><br><span class="line">			rf.logInfo(<span class="string">"LeaderElection timeout"</span>)</span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.beFollowerCh:</span><br><span class="line">			rf.logInfo(<span class="string">"Convert to Follower from candidate"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> ok := &lt;-votedCh:</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				rf.Lock()</span><br><span class="line">				rf.role = leader</span><br><span class="line">				rf.Unlock()</span><br><span class="line">				rf.logInfo(<span class="string">"Leader election succeed"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				rf.logInfo(<span class="string">"Leader election fail"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> args := &lt;-rf.heartBeatCh:</span><br><span class="line">			rf.logInfo(<span class="string">"LeaderElection fail, find new leader&lt;%d,%d&gt;"</span>, args.LeaderId, args.Term)</span><br><span class="line">			rf.beFollowerLocked(rf.votedFor, args.Term)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// election fail, quit requestVote goroutine</span></span><br><span class="line">		<span class="built_in">close</span>(quitCh)</span><br><span class="line">		<span class="keyword">if</span> time.Since(start) &lt; election &#123;</span><br><span class="line">			time.Sleep(election - time.Since(start))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Leader">Leader</h4><p>Leader要做的事情会多一点，毕竟它是leader。</p>
<p>首先，它需要用心跳维护自己的leader地位，有点lease的意思。开始当选leader时，就要发送一个心跳，结束其他candidate。之后如果需要维护一个定期的心跳。</p>
<p>其次，它需要处理客户端的请求，如果收到客户端的command，leader需要将其append到自己的日志，得到command的index。至于何时返回给客户端，看起来则是可以选择的，如果append之后直接返回，那么可能发生日志没有成功提交的情况，如果apply 到SM之后再返回，那么可能永远不会返回，也许是需要一个timeout。</p>
<p>除此之外，就是日志复制了。paper将客户端提交日志和日志复制两块分开了，我们在实现的时候也需要仔细考虑，何时进行日志复制，如果提交一条就复制，那么吞吐量可能跟不上，如果定期复制，延迟也许又会比较大。不过通用的规则时，lastLogIndx &gt;= nextIndex，就发送日志，如果返回成功，更新matchIndex nextIndex，如果失败，回退nextIndex，重试。</p>
<p>日志复制之后，需要进行commit。commit要满足majority的原则，如果存在 N &gt; commitIndex, majority matchIndex[i] &gt; N，并且log[N].term == currentTerm，commitIndex = N。Raft仅仅commit当前term的日志，不过也间接commit了之前的日志。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> (rf *Raft) doLeader() &#123;</span><br><span class="line">	rf.logInfo(<span class="string">"Become leader"</span>)</span><br><span class="line">	<span class="keyword">defer</span> rf.logInfo(<span class="string">"Leader quit."</span>)</span><br><span class="line"></span><br><span class="line">	rf.Lock()</span><br><span class="line">	rf.nextIndex = <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> rf.nextIndex &#123;</span><br><span class="line">		rf.nextIndex[i] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">	&#125;</span><br><span class="line">	rf.matchIndex = <span class="built_in">make</span>([]<span class="typename">int</span>, <span class="built_in">len</span>(rf.peers))</span><br><span class="line">	rf.commitCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line">	rf.submitCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line">	rf.Unlock()</span><br><span class="line">	quitCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)</span><br><span class="line">	done := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">		<span class="keyword">if</span> i != rf.me &#123;</span><br><span class="line">			<span class="keyword">go</span> rf.replicator(i, quitCh, done)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> rf.committer(quitCh, done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// todo: need a elegant way to trigger leader to quit</span></span><br><span class="line">	&lt;-rf.beFollowerCh</span><br><span class="line">	<span class="built_in">close</span>(quitCh)</span><br><span class="line">	done.Wait()</span><br><span class="line">	rf.logInfo(<span class="string">"Leader quit, close committer, replicators. And cleanup submit channel"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conclusion">Conclusion</h2><p>Raft说来简单，但深究其实也挺复杂。如果我们仅仅实现一个简单的Raft，那么很简单，如果要追求性能，可能会变得较为复杂，在这种情况下，用哪种cosensus protocol可能就不是那么重要了，不论用哪个，最后的复杂度可能都落在了处理各种corner case和性能提升。Raft在一些corner case 的情况下可能也会出现一些奇怪的情况，例如，如果一个follower和leader 失联，他会不断选举，增大term，并且通过RequestVote告知给其他的peer，进而导致所有节点都变成follower，并且这个选举过程可能一直不会成功。对于这个case，如果follower在进行选举之前，先询问一下其他的server，是否认为leader已经挂了，如果majority认为leader挂了，再进行选举，看起来是能比避免这种情况。</p>
<p>所以，Raft并不是银弹，也不存在银弹。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>MIT6.824 是MIT的 Distributed System 课程，从RPC开始讲起，到主从备份，容错，再到分布式事务，分布式一致性，介绍了分布式系统各方面的内容。这门课程还包含一些实验，lab1是MapReduce实验，实现一个简单MapReduce框架，最终要能够]]>
    </summary>
    
      <category term="MIT6.824" scheme="http://wanghuanming.com/tags/MIT6-824/"/>
    
      <category term="Paxos" scheme="http://wanghuanming.com/tags/Paxos/"/>
    
      <category term="Raft" scheme="http://wanghuanming.com/tags/Raft/"/>
    
      <category term="分布式一致性" scheme="http://wanghuanming.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="分布式系统" scheme="http://wanghuanming.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kudu调研笔记]]></title>
    <link href="http://wanghuanming.com/2016/09/Kudu-note/"/>
    <id>http://wanghuanming.com/2016/09/Kudu-note/</id>
    <published>2016-09-17T10:00:00.000Z</published>
    <updated>2016-09-17T10:18:35.888Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/KUDU_logo.jpg" alt="kudu_logo"></p>
<h2 id="Goal">Goal</h2><p>Kudu 主要面向 OLAP 应用，支持大规模数据存储，支持快速查询，并且支持实时数据更新。相比Hive 之类的SQL on Hadoop，性能会好不少，并且支持数据实时更新，这也是 Hive 的一个痛点；相比于一个传统的 OLAP 数据库，它所支持的数据规模可能要大一点，毕竟 Kudu 是水平扩展的。</p>
<p>Kudu 的paper里提到，它的一个设计目标是统一存储日志数据和线上数据，并且提供高效的查询。这也是我们团队目前想要实现的一个目标。</p>
<h2 id="相关工作">相关工作</h2><p>目前团队使用的 Hive，Hive 能够查询大规模数据，但痛点也很明显：一来占用资源很多，经常一个 MapReduce 的Job 就能跑半个小时几十分钟，对集群资源的占用是相当大的；二来，查询延迟相当高，如果只是跑一些报表还没有太大问题，但是如果着急需要一些数据，等上半个小时可能就是想当麻烦的；三来，Hive 不支持实时数据更新，虽然 ORC 看起来能实现数据更新，但延迟、吞吐量都想当捉急，略显鸡肋。</p>
<p>也有调研过 Hive on HBase 之类的方案，能够实现数据实时更新，但最致命的一点是，它的效率比 Hive 本身还要低，例如在 join 两个大表的时候会用 hash join 的方式，并且赤裸裸地把其中一个表转成 hash table load 到内存里，但千万级的表根本就很难 load 到内存里。对于普通的查询来说，效率也要低不少。究其原因，还是 HBase 的scan 性能不足，对于OLAP 来说，顺序 scan 的性能相当关键，这也是 HDFS 能够胜任的原因所在。</p>
<p>目前看来，基于 HDFS的方案通常都能提供不错的查询性能，但对于 实时更新的要求来说就有点捉襟见肘了；基于HBase、Cassandra的方案能够支持实时数据更新，但 scan 的吞吐量不能满足。</p>
<p>还有一些方案，例如 Facebook 的Presto，一些商业的 OLAP 数据库，Vertica 之类，使用门槛也并不低，并且前景也不明确。</p>
<h2 id="Performance">Performance</h2><p>评价 Kudu，当然是先看性能。官方的 paper 上有一些性能的比较：对于顺序 scan，比parquet 格式的 HDFS 存储性能不相上下；相比于 Apache Phoenix，性能秒杀；而 Random Access 的性能，略逊色于 HBase。</p>
<p>对于这样的结果，应该可以说是非常赞的。不过我们还是持谨慎的态度，自己又做了一次 benchmark。考虑到使用场景，我们并没有采用 tpc－h benchmark，而是 采用了 tpc-ds ，这也是 Hive 所采用的 benchmark，能有效评价大规模数据下的表现。</p>
<p>机器性能一般，四台机器，12核，32GB 内存，SSD 硬盘。实际测试中发现内存和CPU 占用都不太高。</p>
<p>使用了10GB数据的benchmark，具体 benchmark 的结果过于冗长，简而言之，在机器配置接近的情况下（Hive 用了另一个集群跑的，性能要高一点），Kudu 的执行时间通常在 Hive 的十分之一左右。不得不服。不过也存在一些问题，不支持 bulk load，导入数据这一过程还是非常慢的，几亿行的数据要几十分钟了。</p>
<p>不过从目前的结果来看，基本能满足我们的要求。</p>
<h2 id="Features">Features</h2><h4 id="Columar_Storage">Columar Storage</h4><p>既然是面向 OLAP，那么 Kudu 还是使用列式存储，比 HBase 要好一点的是，它每列都是单独存储，几乎没有 column family 的限制。</p>
<h4 id="C++">C++</h4><p>Kudu 使用 C++ 开发，相比于 Hadoop 生态众多使用 java 开发的程序来说，性能会有一定优势，并且在 GC上，算是解决了 HBase GC停顿的痛点。由于使用了 C++，Kudu 在一些细节上也做了很多优化，例如 SSE 指令，在row projection 的时候使用 LLVM 进行 JIT编译，据说这些优化带来了显著的性能提升。不过使用 C++ 也可能会存在一些问题，比如说和 Hadoop 生态的整合如何搞定呢？</p>
<h4 id="Hadoop_Ecosystem">Hadoop Ecosystem</h4><p>Kudu 在开发时完全考虑 Hadoop 生态，尽量减少使用成本。首先查询引擎使用 Impala，如果一开始就使用 Impala 的话使用成本会降低很多；与 Spark 集成时，也有相应的接口，可以把 Kudu 的数据 load 到一个 RDD中进行操作，或者一个 DataFrame，用SparkSQL 进行查询。</p>
<p>实际使用了一番，虽然 API 确实很好用，跟开发一个普通的 Spark 程序别无二致，但是其吞吐量还是差了不少，把整个数据库的内容 load 到内存还是相当慢的。在这一点上应该没办法完全替代 HDFS。</p>
<h4 id="HA">HA</h4><p>Kudu 还是继承了GFS、Bigtable 的传统，集群架构跟 Bigtable 很像，分为 master、tablet server。master 存储元数据，tablet 管理数据。不过 master/slave 的 HA 做得并不好，master 通常还是存在单点问题。在这一点上，Kudu 采用了multi master 的方案：master 的数据用Raft做replication，多个master也分 leader/follower，用Raft 做 leader election。至于 tablet server，也分leader/follower，同样使用 Raft 做replication和leader election。</p>
<p>使用 Raft这样的一致性协议貌似已经成了共识，新出现的分布式系统很少使用简单的 master/slave 了。对于 multi master 的了解还不是很多，不知道会不会带来新的问题。</p>
<h4 id="Partition">Partition</h4><p>Kudu 的 partition 策略有两种，并且是正交的，一种是 hash partition，另一种是range partition。range partition 比较适合时间序列数据，例如日志，可以每天划分一个partition，这样的访问效率也会比较高。</p>
<h4 id="存储模型">存储模型</h4><p>Kudu 的存储模型类似关系模型，支持primary key，数据也是强类型的，有 int、string之类的数据类型。不过目前还不支持辅助索引，也许以后会实现。</p>
<p>一致性模型，支持snapshot scan，用MVCC保证，也就是说一次scan 过程中读到的数据是一致的。不过不支持多行事务，对于 AP数据来说也没有太大的必要性。</p>
<p>时间戳，与 HBase 不同，不支持 write 操作指定时间戳，但是在read 的时候可以指定。</p>
<h4 id="存储引擎">存储引擎</h4><p>Kudu 最大的特点还是它的存储引擎，也是它的性能保证。Kudu 的存储引擎没有像 HBase 一样基于 HDFS，而是基于单机的文件系统。（貌似现在的另一个流行趋势，就是不再基于分布式文件系统来搞分布式数据库了，可能是基于 immutable 存储来搞 mutable 确实比较累。）</p>
<p>单机的存储引擎整合了 LSM、B tree等经典的结构，可以看到 LevelDB、Parquet的影子。存储还是分为 memory 和 disk，数据先写入 memory和 write ahead log，再刷到 disk。整个存储抽象成 RowSet，细化为 MemRowSet 和 DiskRowSet。</p>
<p>MemRowSet，就是一个 B+ tree，树叶节点的大小是 1K，刚好是4块 cache-line（！！！）；使用 SSE2 指令进行 scan，据说性能非常高。</p>
<p>对于 DiskRowSet，分为 base 和 delta，更新的数据写到 delta，定时 compact 到 base，没有像 LevelDB那样使用多级的 LSM。base 是一个经典的列式存储实现，针对不同的数据类型采用了不同的编码方案，例如字典编码、行程编码、front encoding 等等技术都用上了，尽量减少空间占用。在数据存储的基础上，使用了B+ tree 对primary key 进行索引，也用了 BloomFilter 加速查找。值得一提的是，BloomFilter 的大小是4KB，刚好又是filesystem pagecache 的大小。DiskRowSet 的设计借鉴了很多 Parquet 的思想，值得深入学习。</p>
<h2 id="实际使用">实际使用</h2><ul>
<li>部署安装相当简单，添加相应的 repository 就可以安装，配置精简，无须一些乱七八糟的配置</li>
<li>稳定性还可以，跑了几天，也跑了一些负载比较高的任务，没有挂掉</li>
<li>管理控制做的还不是很到位，命令行提供的功能相对较弱</li>
<li>资源占用很少，机器的负载很低</li>
<li>性能相当赞，碾压 Hive 的快感</li>
</ul>
<h2 id="总结">总结</h2><p>之后还会做一些使用跟调研，希望能够尽快在生产环境中用上 Kudu。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/KUDU_logo.jpg" alt="kudu_logo"></p>
<h2 id="Goal">Goal</h2><p>Kudu 主要面向 OLAP 应用，支持大规模数据存储]]>
    </summary>
    
      <category term="Kudu" scheme="http://wanghuanming.com/tags/Kudu/"/>
    
      <category term="OLAP" scheme="http://wanghuanming.com/tags/OLAP/"/>
    
      <category term="分布式系统" scheme="http://wanghuanming.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="存储系统" scheme="http://wanghuanming.com/tags/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="http://wanghuanming.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Reading" scheme="http://wanghuanming.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《LLVM Cookbook》]]></title>
    <link href="http://wanghuanming.com/2016/07/%E3%80%8ALLVM-Cookbook%E3%80%8B/"/>
    <id>http://wanghuanming.com/2016/07/《LLVM-Cookbook》/</id>
    <published>2016-07-09T15:18:00.000Z</published>
    <updated>2016-07-09T15:27:34.508Z</updated>
    <content type="html"><![CDATA[<p>去年翻译的书终于出版了，秀一下：</p>
<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/1.pic.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>去年翻译的书终于出版了，秀一下：</p>
<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/1.pic.jpg" alt=""></p>
]]>
    </summary>
    
      <category term="LLVM" scheme="http://wanghuanming.com/tags/LLVM/"/>
    
      <category term="Life &amp; Work" scheme="http://wanghuanming.com/categories/Life-Work/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[猿题库实习小记]]></title>
    <link href="http://wanghuanming.com/2016/07/%E7%8C%BF%E9%A2%98%E5%BA%93%E5%AE%9E%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <id>http://wanghuanming.com/2016/07/猿题库实习小记/</id>
    <published>2016-07-09T13:27:48.000Z</published>
    <updated>2016-07-09T15:27:12.784Z</updated>
    <content type="html"><![CDATA[<p>四月份的时候，去北京猿题库那边实习了一段时间，到现在也有三个月了。趁着很久没有写博客，写下一些文字作为纪念。</p>
<h2 id="面试">面试</h2><p>三月多刚开始找实习的时候经FPs推荐，面试了一下猿题库。之前听闻猿题库要求比较高，面试以算法为主，所以之前做了一些准备，没有掉以轻心。</p>
<p>两轮面试，一面基本上就是在线写代码，字符串和数组处理的题目，没有太大难度，不过题目稍显复杂， 细节没有处理太好。二面是唐巧面的，问了一些“比较奇怪”的题目，或者说，没有按照套路出牌，但是深得我心。例如，c++里的int有几个字节，这个问题的答案很容易被人误解成4个字节，但C++标准里其实没有规定int几个字节，每个平台都不一样；不过标准规定了int最少是16位，而后来者java算是填了这个坑，直接规定了基本类型的字节数量。这个问题对于老司机来说应该不难，但是对于应届生应该是比较容易被忽视的。之后写了一点代码，也是字符串处理，比较顺畅地搞定。让我比较意外的是，唐巧还问了一些函数式编程的问题，这在之前以及之后的一些面试中都没有面试官提及，也实属难得。可能是因为他当时也在研究FP，问了我Monad是什么，不过我当时其实没有研究monad，就把我之前写过的C++的函数式容器库讲了一下，也算是对函数式编程的一个比较好的应用。</p>
<p>总的来说面试比较愉快，有代码能力的考察，也有实践经验的考察，以及技能树，没有像某些公司一样硬搬一些程序员面试宝典里的题目过来，也没有欺负实习生问一些工程相关的问题。而正是因为之前的面试都不太愉快，所以我也很快决定去猿题库那边实习了。</p>
<h2 id="到达北京">到达北京</h2><p>去北京之前还是比较忐忑的，毕竟人生地不熟，自己租房，自己生活。好在公司的氛围很不错，人情味也比较浓。入职的第一天，mentor就带我去部门转了一圈，认识了一下各位同事。之后又去领了设备，MacbookPro，Filco键盘之类的，而且竟然都是新的，让我颇感惊讶。</p>
<h2 id="实习生活">实习生活</h2><p>在猿题库的职位是猿辅导服务器端开发，这边的技术栈以java为主，以及Spring、Thrift、ZooKeeper、MySQL、RabbitMQ、Redis、MicroService之类的技术，因为之前都没有接触过，吭哧吭哧在mentor的指导下花了一两个月才算入门，也学到了工程开发中的蛮多东西，单元测试，持续集成，Scrum之类的。总的来说在这边接触的东西比较多，从产品稿到服务实现，再到服务上线，实习生都能接触到。我觉得对于实习生来说，有这样的实习机会是相当不错的。</p>
<p>在这边学到的另一个比较有意思的东西是Scrum。Scrum看起来只是一个开发流程，或者是软件工程的一个开发方法。但我后来发现，其实把它视作一种时间管理的方法也是非常好的。对于平时的一些想法，可以存到backlog中，以备有空的时候去实现。而每周可以给自己总backlog中分配一些任务，具体到每天的工作，可以在每天早上上班的时候考虑一下，今天要搞哪些工作，要读哪些文章，要解决哪些问题。例如计划一周要读一本书，可以按照书的目录分解，周一读第一章，周二读第二章。这样一来任务也比较明确，每天都有固定的目标，不容易懈怠。同时，也可以使用一些工具，我目前使用的是TickTick，感觉还不错。</p>
<p>公司是早上十点上班，一般我会九点多到公司，看看书，或者学习一下前一天遇到的一些问题。利用一些零碎的时间，也看了一些书，关于微服务，Spring之类。虽然公司周末一般不用加班，但我周六基本都会到公司看书，或者写写代码，主要是因为住的地方环境实在是比较糟糕，而公司反而清静一点。三个月过来，感觉这样的生活节奏应该是比较理想的。自己在业余时间也算是学了不少东西，相比于学校里的生活，节奏紧张了一点，但在压力之下学习效率也提高了不少。</p>
<h2 id="未来计划">未来计划</h2><p>实习了一段时间，对未来的发展也有了一些眉目。目前在学习一些关于数据库，存储系统，分布式系统方面的内容，感觉也非常有意思，也许未来会往这方面发展。</p>
<p>想来，自己也算是比较能折腾的，一开始搞Nodejs，搞Web开发，后来又去搞C++，搞操作系统，编译器，之后又玩了一段时间Spark，再是java，到现在又在学数据库。虽然好像都没有搞出什么名堂，但未来的事情谁又知道会怎样呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>四月份的时候，去北京猿题库那边实习了一段时间，到现在也有三个月了。趁着很久没有写博客，写下一些文字作为纪念。</p>
<h2 id="面试">面试</h2><p>三月多刚开始找实习的时候经FPs推荐，面试了一下猿题库。之前听闻猿题库要求比较高，面试以算法为主，所以之前做了一]]>
    </summary>
    
      <category term="实习" scheme="http://wanghuanming.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="猿题库" scheme="http://wanghuanming.com/tags/%E7%8C%BF%E9%A2%98%E5%BA%93/"/>
    
      <category term="Life &amp; Work" scheme="http://wanghuanming.com/categories/Life-Work/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MINIX文件系统设计与实现]]></title>
    <link href="http://wanghuanming.com/2016/01/development%20and%20implementation%20of%20minix%20file%20system/"/>
    <id>http://wanghuanming.com/2016/01/development and implementation of minix file system/</id>
    <published>2016-01-06T04:40:44.000Z</published>
    <updated>2016-01-06T15:47:28.700Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/Files.jpeg" alt="files"></p>
<h2 id="缘起">缘起</h2><p>前一段时间听<a href="http://weibo.com/u/2258096562?sudaref=airtrack.me" target="_blank" rel="external">airtrack</a>说他在写文件系统，写起来很麻烦，“一个mkfs工具就快1000行代码了”。很早之前就看到他在写内核，貌似是15年上半年就开始，虽然节奏比较慢，但是非常持之以恒，写到了16年。而我就没什么耐心，实现了一些基本功能之后就没什么兴趣了，实在是惭愧。</p>
<p>听他那么一说，于是决定也写一个文件系统试试，找了找资料，好像也不是很难的样子。遂决定从MINIX入手，写一个玩具版的FS。</p>
<h2 id="MINIX_FS简介">MINIX FS简介</h2><p>MINIX文件系统是MINIX操作系统原生的文件系统。说到MINIX，它是 Andrew S. Tanenbaum在80年代写的一个用于教学的操作系统，采用了微内核，模仿了Unix系统，但是代码比较clean，可读性也会比较好。由于是用于教学，MINIX文件系统只实现了一些基本的功能，因此比较精简。再后来Linus开发Linux0.11的时候，也是参照这个文件系统来实现的。不过Linux跟MINIX很大的一个区别就是内核架构，Linux是宏内核，MINIX是微内核。</p>
<p>MINIX采用了索引式分配，实现了树形目录结构，对磁盘有一个缓冲层，支持管道等功能。</p>
<h2 id="准备工作">准备工作</h2><p>为了实现文件系统，我们首先需要一个磁盘，来承载这个文件系统。我这里使用了qemu虚拟机，它支持磁盘镜像的挂载，所以我们现在需要做的就是创建一个磁盘镜像，把它格式化成MINIX 文件系统。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dd</span> <span class="keyword">if</span>=/dev/zero of=hdd<span class="class">.img</span> bs=<span class="number">1</span>M count=<span class="number">10</span></span><br><span class="line">mkfs<span class="class">.minix</span> -<span class="tag">i</span> <span class="number">128</span> hdd.img</span><br></pre></td></tr></table></figure>
<p>这就搞定了，用dd创建一个10MB的磁盘镜像，然后用mkfs个格式化一下。那个-i参数是指定inode的数量，当然还有其他一些参数也可以设定。</p>
<p>接着就是挂载，也是轻而易举：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">qemu</span>  -kernel ./Sprite -hda hdd.img</span><br></pre></td></tr></table></figure></p>
<p>我这里直接用-kernel来挂载了我的内核（Sprite），就不用把这个内核写到软盘镜像或者硬盘镜像还要安装grub什么的。</p>
<p>磁盘镜像的事情已经搞定，接下来就是磁盘驱动。这部分代码不在我们的讨论范畴之内，只是简单看一下磁盘的读写接口：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ide_read_secs</span><span class="params">(uint32_t secno, <span class="keyword">void</span>* dst, uint32_t nsecs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ide_write_secs</span><span class="params">(uint32_t secon, <span class="keyword">const</span> <span class="keyword">void</span>* src, uint32_t nsecs)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>ide_read_secs就是读磁盘，secno是扇区号（准确地讲是LBA地址），从0开始，dst就不用说了，nsecs是读的扇区数量。磁盘驱动通常会有一次读写的扇区数量限制，不过我在这里已经把这部分处理写到驱动里了，所以这里的nsecs理论上讲可以是非常大，没有什么限制。</p>
<p>从这个接口也可以看出，磁盘读写都是以扇区为单位，通常大小是512byte。地址空间也可以当做是线性的地址空间，这个地址最终会映射到磁道、扇区、簇什么的。所以所谓文件系统，就是对这么一个空间的管理，看起来跟写一个内存分配器很像？</p>
<h2 id="磁盘布局">磁盘布局</h2><p>首先来看一下MINIX FS的磁盘布局：<br><img src="http://7ktrkd.com1.z0.glb.clouddn.com/fs-layout.gif" alt="fs layout"></p>
<ul>
<li>bootblock: 引导块，包括系统的引导代码，和分区表。跟我们没关系</li>
<li>superblock：超级块，每个磁盘分区都会有超级块，记录了文件系统的元数据。顺便说一句，每个磁盘分区都可以安装不同的文件系统，所以一个文件系统的管理范围通常就是一个分区。</li>
<li>inode bitmap：用来记录inode的分配情况</li>
<li>zone bitmap：用来记录文件区域的分配情况</li>
<li>inodes：存放inode</li>
<li>file data blocks: 存放真正的文件数据</li>
</ul>
<p>首先什么是block？在这里它不仅是一个概念上的称呼，还是一个计量单位，通常是1KB。所以boot block、super block它们占据的空间都是1KB。我们可以认为block就是MINIX FS磁盘管理的最小单位了。</p>
<p>除了block之外，还有一个单位是zone，它的存在是为了提高磁盘IO性能。对于机械硬盘来说，通常认为一次读很多数据，比多次读小的数据要来得快，因为涉及到磁头的移动什么的。因此在磁盘空间分配的时候，就把分配的单位定为zone，可以是1个block，4个block等等。不过把最小分配单位增大也有坏处，就是会增加内部碎片，一个1byte的文件至少要占据一个zone的空间，是比较浪费的。所以为了权衡性能和空间利用率，设置了一个不大不小的zone。mkfs设置的默认zone大小和block一致，都是1KB。</p>
<p>inode，在MINIX FS中直接存放在特定的区域。inode记录了文件的元数据，由于是采用索引分配，所以它基本记录了文件的大小，数据位置，修改时间，权限等等信息。每个inode对应一个文件，不过这里的文件指的是广义的文件，出了regular file之外，还包括目录。也就是说，MINIX FS中目录其实就是一种特殊的文件。熟悉Linux的同学应该还知道link，那么link是怎么实现的呢，如果是hard link，其实就是另外一个inode，指向了目标文件的数据，换言之就是两个inode指向了同一个文件。</p>
<p>OK，基本结构就是这样，下面看一下结构体的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> d_inode &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> mode;      <span class="comment">// file type and RWX mode</span></span><br><span class="line">    <span class="keyword">uint16_t</span> uid;       <span class="comment">// user ID</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;      <span class="comment">// file size</span></span><br><span class="line">    <span class="keyword">uint32_t</span> mtime;     <span class="comment">// modify time since 1970</span></span><br><span class="line">    <span class="keyword">uint8_t</span> gid;        <span class="comment">// group id</span></span><br><span class="line">    <span class="keyword">uint8_t</span> num_links;  <span class="comment">// hard link number</span></span><br><span class="line">    <span class="keyword">uint16_t</span> zone[<span class="number">9</span>];   <span class="comment">// zone[0] ~ zone[6] direct pointer, zone[7] points to first level index</span></span><br><span class="line">                        <span class="comment">// table, zone[8] second level.</span></span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * in memory inode</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> m_inode &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> mode;</span><br><span class="line">    <span class="keyword">uint16_t</span> uid;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">    <span class="keyword">uint32_t</span> mtime;</span><br><span class="line">    <span class="keyword">uint8_t</span> gid;</span><br><span class="line">    <span class="keyword">uint8_t</span> num_links;</span><br><span class="line">    <span class="keyword">uint16_t</span> zone[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    task_struct* wait;</span><br><span class="line">    <span class="keyword">uint32_t</span> atime;</span><br><span class="line">    <span class="keyword">uint32_t</span> ctime;</span><br><span class="line">    <span class="keyword">uint16_t</span> dev;</span><br><span class="line">    <span class="keyword">uint16_t</span> num;</span><br><span class="line">    <span class="keyword">uint16_t</span> count;</span><br><span class="line">    <span class="keyword">uint8_t</span> lock;</span><br><span class="line">    <span class="keyword">uint8_t</span> dir;</span><br><span class="line">    <span class="keyword">uint8_t</span> pipe;</span><br><span class="line">    <span class="keyword">uint8_t</span> mount;</span><br><span class="line">    <span class="keyword">uint8_t</span> seek;</span><br><span class="line">    <span class="keyword">uint8_t</span> update;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> super_block &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_inodes;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_zones;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_imap_blocks;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_zmap_blocks;</span><br><span class="line">    <span class="keyword">uint16_t</span> first_data_zone;</span><br><span class="line">    <span class="keyword">uint16_t</span> log_zone_size;</span><br><span class="line">    <span class="keyword">uint32_t</span> max_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> magic;</span><br><span class="line">    <span class="comment">/* These are only in memory */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> dev;</span><br><span class="line">    m_inode* isup;</span><br><span class="line">    m_inode* imount;</span><br><span class="line">    <span class="keyword">uint32_t</span> time;</span><br><span class="line">    task_struct* wait;</span><br><span class="line">    <span class="keyword">uint8_t</span> lock;</span><br><span class="line">    <span class="keyword">uint8_t</span> rd_only;</span><br><span class="line">    <span class="keyword">uint8_t</span> dirt;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> d_super_block &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_inodes;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_zones;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_imap_blocks;</span><br><span class="line">    <span class="keyword">uint16_t</span> num_zmap_blocks;</span><br><span class="line">    <span class="keyword">uint16_t</span> first_data_zone;</span><br><span class="line">    <span class="keyword">uint16_t</span> log_zone_size;</span><br><span class="line">    <span class="keyword">uint32_t</span> max_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> magic;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dir_entry &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> inode;</span><br><span class="line">    <span class="keyword">char</span> name[kNameLen];</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>这里的superblock和inode定义都有两种，一个是磁盘中的，一个在内存中。在磁盘中的结构我们不能修改，不过在内存中的其实可以根据需要修改。</p>
<h2 id="Block_cache">Block cache</h2><p>按理说接下来要做的就是把这些磁盘中的数据载入内存，但是还要等等，在此之前我们需要先实现缓冲区。</p>
<p>block cache是为了提高文件系统系统的性能。这个block cache事实上起到了两个作用，一是buffer，二是cache。首先是buffer，由于磁盘一次至少读一个扇区，所以我们读数据的时候需要一个缓冲区，把一个扇区的数据读到缓冲区里，再进行操作；而这个缓冲区的内存由block cache统一管理，所以我们可以重用缓冲区，来实现缓存。比如说一个线程读了某一个扇区，另一个线程再来读，就不用再去磁盘读取了，可以从缓存里来拿。</p>
<p>缓冲区的大小是一个block，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> block_buffer &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[kBlockSize]; <span class="comment">/* block data */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> count;            <span class="comment">/* users using this block */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> lock;             <span class="comment">/* 0 - ok, 1 -locked */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我这里把很多东西都删了，跟Linux 0.11的写法有些出入。由于data是在结构体的开头，所以我们如果拿到block_buffer的指针，可以直接当做buffer来用，不用再<code>buff-&gt;data</code>，省了一点麻烦。</p>
<p>至于缓存的实现，就有很大的发挥空间。我实现了一个LRU，大致接口如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> LRUCache &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> uncache_callback = <span class="keyword">void</span> (*)(<span class="keyword">size_t</span>, T*);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetUncacheHandler</span><span class="params">(uncache_callback cb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">Alloc</span><span class="params">(size_t key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">Get</span><span class="params">(size_t key)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Alloc是分配一个缓存，返回指针；Get则是拿缓存，如果miss返回nullptr；至于<code>SetUncacheHandler</code>，是设置当缓存失效时的一个回调，通常来说如果要取消一个缓存，要先把内存的数据写到磁盘里，这里的回调就是这个意思。</p>
<p>缓冲区和缓存都有了，接下来就是把它们封装到一起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LRUCache&lt;block_buffer, <span class="number">307</span>&gt; g_block_cache;</span><br><span class="line"></span><br><span class="line"><span class="function">block_buffer* <span class="title">get_block</span><span class="params">(uint32_t bno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> buff = g_block_cache.Get(bno);</span><br><span class="line">    <span class="keyword">if</span> (!buff) &#123;</span><br><span class="line">        buff = g_block_cache.Alloc(bno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">block_buffer* <span class="title">read_block</span><span class="params">(uint32_t bno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the data in cache is always uptodate, so we could directly return it</span></span><br><span class="line">    <span class="keyword">auto</span> buff = g_block_cache.Get(bno);</span><br><span class="line">    <span class="keyword">if</span> (!buff) &#123;</span><br><span class="line">        buff = g_block_cache.Alloc(bno);</span><br><span class="line">        ide_read_secs(block_to_sector(bno), buff, block_to_sector(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write_block</span><span class="params">(uint32_t bno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> buff = g_block_cache.Get(bno)) &#123;</span><br><span class="line">        ide_write_secs(block_to_sector(bno), buff, block_to_sector(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read不用说，而write之前需要先用get获取缓冲区，把数据写到缓冲区里，然后write一下。有了这个接口之后，我们就可以读写磁盘数据了。</p>
<h2 id="初始化">初始化</h2><p>FS的初始化就是要把这些磁盘中的数据读入内存，包括super block, inode bitmap, zone bitmap, inodes。说来也简单，在内存中定义好这些结构，然后读入一下就好了。</p>
<p>这些数据定义成全局变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> super_block g_super_block;           </span><br><span class="line"><span class="keyword">extern</span> LRUCache&lt;block_buffer, <span class="number">307</span>&gt; g_block_cache;</span><br><span class="line"><span class="keyword">extern</span> m_inode g_inode_table[kNumInodes];</span><br><span class="line"><span class="keyword">extern</span> bitmap&lt;<span class="number">128</span>&gt; g_imap;</span><br><span class="line"><span class="keyword">extern</span> bitmap&lt;<span class="number">10240</span>&gt; g_zmap;</span><br></pre></td></tr></table></figure>
<p>读入的话，会有一点小问题，因为磁盘是按块读，不连续的，而这些数据内存都是连续的，要如何对接呢？所以我写了一个高级的接口，用来读多个block：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Input, <span class="keyword">class</span> Output&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_blocks</span><span class="params">(size_t start_bno, <span class="keyword">void</span>* dst, size_t count, size_t size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> block = <span class="keyword">reinterpret_cast</span>&lt;Input*&gt;(read_block(start_bno));</span><br><span class="line">    <span class="keyword">auto</span> src = block;</span><br><span class="line">    <span class="keyword">auto</span> dst_ = <span class="keyword">reinterpret_cast</span>&lt;Output*&gt;(dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++, dst_++, src++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uint8_t</span>*)src &gt;= (<span class="keyword">uint8_t</span>*)block + kBlockSize) &#123;</span><br><span class="line">            src = block = <span class="keyword">reinterpret_cast</span>&lt;Input*&gt;(read_block(++start_bno));</span><br><span class="line">            <span class="keyword">if</span> (!src) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(dst_, src, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数实现了读取磁盘上的结构到内存里：<code>start_bno</code>，起始的block地址；<code>dst</code>，目标地址；<code>count</code>，结构体的数量；<code>size</code>，每个结构体要拷贝的大小。模版参数都需要手动指定，不使用自动推导，<code>Input</code>是磁盘中的结构体类型，<code>Output</code>是内存中的结构体类型，之所以会有两个，是因为很多时候同一个数据我们希望拷贝到内存中可以附加其他一些信息，也就是说结构体会不一致。</p>
<p>例如，要读取所有的inode到内存，只要这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> block_start = <span class="number">2</span> + g_super_block.num_imap_blocks + g_super_block.num_zmap_blocks;</span><br><span class="line">    read_blocks&lt;d_inode, m_inode&gt;(block_start, g_inode_table + <span class="number">1</span>, g_super_block.num_inodes,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(d_inode));</span><br></pre></td></tr></table></figure></p>
<p>这里磁盘中的inode和内存里的就不一样，分别是d_inode和m_inode，每次拷贝的数据是d_inode的大小，而inode的数量是<code>g_super_block.num_inodes</code>。</p>
<p>其他数据的载入也是与此类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init super block</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;g_super_block, read_block(kSuperBlockBNO), <span class="keyword">sizeof</span>(g_super_block));</span><br><span class="line">    <span class="comment">// init block cache</span></span><br><span class="line">    g_block_cache.SetUncacheCallback(&amp;uncache);</span><br><span class="line">    <span class="comment">// init inode table</span></span><br><span class="line">    <span class="keyword">int</span> block_start = <span class="number">2</span> + g_super_block.num_imap_blocks + g_super_block.num_zmap_blocks;</span><br><span class="line">    read_blocks&lt;d_inode, m_inode&gt;(block_start, g_inode_table + <span class="number">1</span>, g_super_block.num_inodes,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(d_inode));</span><br><span class="line">    <span class="comment">// init bitmap</span></span><br><span class="line">    <span class="keyword">int</span> imap_start = <span class="number">2</span>;</span><br><span class="line">    read_blocks&lt;<span class="keyword">uint8_t</span>, <span class="keyword">uint8_t</span>&gt;(imap_start, g_imap.data_, g_super_block.num_inodes / <span class="number">8</span>,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="keyword">int</span> zmap_start = <span class="number">2</span> + g_super_block.num_imap_blocks;</span><br><span class="line">    read_blocks&lt;<span class="keyword">uint8_t</span>, <span class="keyword">uint8_t</span>&gt;(zmap_start, g_zmap.data_, g_super_block.num_zones / <span class="number">8</span>,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br></pre></td></tr></table></figure>
<p>到这里，基本实现了文件系统元数据的读取，接下来要做的，就是如何读一个文件。</p>
<h2 id="文件读取">文件读取</h2><p>在索引式文件系统中，文件的数据不一定是连续的。文件会被分为很多小的zone，分布在磁盘的各个位置，这个也称为fragmentation。这种技术很常用，在内存管理中也用到了这样的技术。</p>
<p>这些位置记录在inode中，用2byte记录一个zone的位置，如果只是直接记录地址，那么也就是2byte =&gt; 1KB，那么每个inode要用多少大小来记录呢？如果太小，导致文件的大小也会被限制，如果花比较大的空间来记录位置，那么对小文件来说它可能只需要1个zone，那就太浪费了。所以这里采用了多级索引的技术，跟虚拟内存分页的多级页表非常像。</p>
<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/unix_inode.png" alt="inode"></p>
<p>这里使用两级的索引表，所以文件最大是7 + 512 + 512×512个zone。由于多级索引，所以文件的数据也是不连续，对读取造成了一些小困难，我们为文件读取封装一个跟好用的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">block_buffer* <span class="title">read_zone</span><span class="params">(<span class="keyword">const</span> m_inode* inode, uint32_t zone)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zone &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> read_block(inode-&gt;zone[zone]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zone &lt; <span class="number">7</span> + <span class="number">512</span>) &#123;</span><br><span class="line">        zone -= <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">auto</span> zones = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint16_t</span>*&gt;(read_block(inode-&gt;zone[<span class="number">7</span>]));</span><br><span class="line">        <span class="keyword">return</span> read_block(zones[zone]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zone -= <span class="number">7</span> + <span class="number">512</span>;</span><br><span class="line">        <span class="keyword">auto</span> zone_table = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint16_t</span>*&gt;(read_block(inode-&gt;zone[<span class="number">8</span>]));</span><br><span class="line">        <span class="keyword">auto</span> zones = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint16_t</span>*&gt;(read_block(zone_table[zone / <span class="number">512</span>]));</span><br><span class="line">        <span class="keyword">return</span> read_block(zones[zone % <span class="number">512</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分了三级，第一级直接读取，第二级先读索引表，然后读数据。于是乎，我们可以尝试着读一个文件了。</p>
<p>由于现在磁盘中还没有文件，我们可以读一下根目录的数据（它的inode 编号是1）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">printk(<span class="string">"files in /\nname\tsize\ttype\n"</span>);</span><br><span class="line"><span class="keyword">auto</span> dir = &amp;g_inode_table[kRootINO]；</span><br><span class="line"><span class="keyword">int</span> zone_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> zone = <span class="keyword">reinterpret_cast</span>&lt;dir_entry*&gt;(read_zone(dir, zone_cnt));</span><br><span class="line"><span class="keyword">auto</span> entry = zone;</span><br><span class="line"><span class="keyword">int</span> num_entries = dir-&gt;size / <span class="keyword">sizeof</span>(dir_entry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_entries; i++, ++entry) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uint8_t</span>*)entry &gt;= (<span class="keyword">uint8_t</span>*)zone + kZoneSize) &#123;</span><br><span class="line">        zone = entry = <span class="keyword">reinterpret_cast</span>&lt;dir_entry*&gt;(read_zone(dir, ++zone_cnt));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> node = g_inode_table + entry-&gt;inode;</span><br><span class="line">    printk(<span class="string">"%s\t%d\t%s\n"</span>, entry-&gt;name, node-&gt;size,</span><br><span class="line">           is_directory(node-&gt;mode) ? <span class="string">"dir"</span> : <span class="string">"file"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是乎得到了这样的结果：</p>
<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/fs-output1.png" alt="结果"></p>
<p>根目录下有两个文件，. 和 ..，应该不陌生吧？</p>
<h2 id="路径">路径</h2><p>接下来我们要实现目录和路径。先在镜像中创建一个目录，以及一个文件。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mount hdd.img <span class="regexp">/mnt/</span>kernel</span><br><span class="line">mkdir <span class="regexp">/mnt/</span>kernel/test</span><br><span class="line">echo <span class="string">"helloworld"</span> &gt; <span class="regexp">/mnt/</span>kernel<span class="regexp">/test/</span>test.txt</span><br><span class="line">sudo umount <span class="regexp">/mnt/</span>kernel</span><br></pre></td></tr></table></figure>
<p>以及相关的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn&gt;</span><br><span class="line"><span class="function">m_inode* <span class="title">traverse_dir</span><span class="params">(<span class="keyword">const</span> m_inode* dir, Fn cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_directory(dir-&gt;mode)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> zone_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> zone = <span class="keyword">reinterpret_cast</span>&lt;dir_entry*&gt;(read_zone(dir, zone_cnt));</span><br><span class="line">    <span class="keyword">auto</span> entry = zone;</span><br><span class="line">    <span class="keyword">int</span> num_entries = dir-&gt;size / <span class="keyword">sizeof</span>(dir_entry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_entries; i++, ++entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uint8_t</span>*)entry &gt;= (<span class="keyword">uint8_t</span>*)zone + kZoneSize) &#123;</span><br><span class="line">            zone = entry = <span class="keyword">reinterpret_cast</span>&lt;dir_entry*&gt;(read_zone(dir, ++zone_cnt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cb(entry)) <span class="keyword">return</span> g_inode_table + entry-&gt;inode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Find an entry in a dir, it could be a directory or a regular file.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">m_inode* <span class="title">find_entry</span><span class="params">(<span class="keyword">const</span> m_inode* dir, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_directory(dir-&gt;mode)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traverse_dir(dir, [name](dir_entry* entry) &#123; <span class="keyword">return</span> <span class="built_in">strcmp</span>(entry-&gt;name, name) == <span class="number">0</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Find the inode for the specific name</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">m_inode* <span class="title">namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span> </span>&#123;</span><br><span class="line">    assert(path[<span class="number">0</span>] == <span class="string">'/'</span>, <span class="string">"path must start with /"</span>);</span><br><span class="line">    m_inode* inode = g_inode_table + kRootINO;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* delim = path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        path = delim + <span class="number">1</span>;</span><br><span class="line">        delim = strfind(path, <span class="string">'/'</span>);</span><br><span class="line">        inode = find_entry(inode, path);</span><br><span class="line">        <span class="keyword">if</span> (!*delim)  <span class="comment">// reach the last entry</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>traver_dir用来遍历目录，在此基础上实现了文件查找和路径的解析。路径解析写的比较简陋，只能从根目录开始，也没有什么鲁棒性，不过基本够用了。</p>
<p>所以，可以借此来读一个文件了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> node = namei(<span class="string">"/test/test.txt"</span>)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> contents = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(read_zone(node, <span class="number">0</span>));</span><br><span class="line">    printk(<span class="string">"size: %d; contents of test.txt: %s\n"</span>, node-&gt;size, contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>轻松愉快。</p>
<h2 id="总结">总结</h2><p>很遗憾，到这里就没有了，接下来其实还有很大的发挥空间，不过因为我要期末考试了，就先写到这里了。</p>
<h2 id="References">References</h2><ul>
<li><a href="https://www.google.com.sg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwia5tmJ2JTKAhWXj44KHazPCjMQFggbMAA&amp;url=http%3A%2F%2Fbachue.is-programmer.com%2Fuser_files%2FBachue%2FFile%2FLinux%25200.11%25E6%2596%2587%25E4%25BB%25B6%25E7%25B3%25BB%25E7%25BB%259F%25E7%259A%2584%25E5%25AE%259E%25E7%258E%25B0.pdf&amp;usg=AFQjCNEKUlEAP8QISWZeZAAHa-gr838CmQ&amp;sig2=XWnaAKEyE7WLLg391AfYDg" target="_blank" rel="external">Linux0.11文件系统</a></li>
<li><a href="https://www.google.com.sg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0ahUKEwj6zYmw2JTKAhUDUY4KHW3UDYAQFggsMAI&amp;url=https%3A%2F%2Fkoala.cs.pub.ro%2Fredmine%2Fattachments%2Fdownload%2F105%2Fminix.pdf&amp;usg=AFQjCNHwfzNM-lIEjSAZ5GLQdm0w5MJsqQ&amp;sig2=fJHU98XaCMrK6aTBJWxDVw&amp;bvm=bv.110151844,d.c2E" target="_blank" rel="external">MINIX File System</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/Files.jpeg" alt="files"></p>
<h2 id="缘起">缘起</h2><p>前一段时间听<a href="http://weibo.com/u/2258]]>
    </summary>
    
      <category term="File system" scheme="http://wanghuanming.com/tags/File-system/"/>
    
      <category term="MINIX" scheme="http://wanghuanming.com/tags/MINIX/"/>
    
      <category term="OS" scheme="http://wanghuanming.com/tags/OS/"/>
    
      <category term="文件系统" scheme="http://wanghuanming.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Coroutine的实现]]></title>
    <link href="http://wanghuanming.com/2015/12/implementation%20of%20coroutine/"/>
    <id>http://wanghuanming.com/2015/12/implementation of coroutine/</id>
    <published>2015-12-25T00:58:50.000Z</published>
    <updated>2015-12-25T02:02:52.467Z</updated>
    <content type="html"><![CDATA[<p>闲来无事，实现了一个协程。目前实现的特性有：</p>
<ol>
<li>手动yield、resume</li>
<li>支持在yield的时候传递变量</li>
<li>使用copy stack来减少协程的大小，目前每个协程需要1928B内存</li>
</ol>
<p>简单讲一下实现的方法。</p>
<h2 id="resume_yield">resume yield</h2><p>协程首要的一个特性就是可以自己挂起，自己恢复，因此我们可以把它当做一个可以暂停、可以多次返回值的函数。为此，需要保存这个函数的上下文，并且让函数运行在另外的栈上。</p>
<p>所谓函数上下文，就是把函数使用的寄存器保存一下；而保存栈的话，则是为了防止主程序来践踏协程栈，因此也需要另外保存。保存上下文有多种方法，自己用汇编写一个也很简单，或者用linux提供的ucontext，以及其他一些方法。</p>
<p>我这里使用了ucontext，它同时提供了上下文切换的功能，有四个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getcontext(<span class="keyword">ucontext_t</span>* ctx);</span><br><span class="line">setcontext(<span class="keyword">ucontext_t</span>* ctx);</span><br><span class="line">makecontext(<span class="keyword">ucontext_t</span>* ctx, <span class="keyword">void</span>(*fn)(), <span class="keyword">int</span> argc, ...)</span><br><span class="line">swapcontext(<span class="keyword">ucontext_t</span>* old, <span class="keyword">ucontext_t</span>* ctx);</span><br></pre></td></tr></table></figure></p>
<p>getcontext用来保存当前的上下文到ctx；setcontext是把当前的上下文设置为ctx；makecontext则是用来修改ctx，把ctx的入口改成函数fn，并且可以传递参数给fn；swapcontext实现上下文切换，保存当前上下文到old，切换到ctx。这里的swapcontext看起来有点多余，用get再set不就可以了吗？其实不是的，swapcontext实现的效果是“原子”切换上下文，而先get，保存了当前上下文，再切换到新的。当线程的上下文再切回到old的时候，如何是用get、set保存的，回到的是getcontext的下一条指令即setcontext函数；而用swapcontext保存的话，回到的则是swapcontext的下一条指令，也相当于从swapcontext函数返回，并继续执行。</p>
<p>那么swapcontext如何实现呢？这和我之前写kernel的时候写的线程切换也差不多。首先明确其功能，swapcontext是一个函数，用来保存caller的下一条指令地址，以及caller的其他寄存器。但是一般的函数调用首先就会修改sp、bp、ip，所以我们需要用汇编来写。ip保存caller下一条指令地址，其实就是返回地址，[sp]就是了；sp、bp直接保存，因为我们没有修改它的值。当然，这都是我猜的。。</p>
<p>顺便再猜一下makecontext的实现。把函数地址保存到ip，至于传参的话，就先把参数push到栈里，再留一个返回地址的占位，应该就能搞定了。</p>
<p>所以，有了ucontext之后，实现resume就是先swapcontext（主程序上下文，协程上下文），而yield就是反过来swapcontext（协程上下文，主程序上下文）。很简单。</p>
<h2 id="传递变量">传递变量</h2><p>yield还有一个重要功能就是可以传递一个变量到主程序，我们可以用这种方式来实现generator。这里的传递不是函数返回，而是变量在不同上下文之后的传递，因为yield会切换到resume保存的上下文，我们只要把这个变量传给resume的上下文，让resume函数直接返回这个变量就ok了。那么，如何传递呢？无疑是要借助堆内存了，yield把变量放到堆中，把地址告诉resume，然后resume取出来，释放内存。so，地址要怎么传递？可以用一个类成员来传递这个地址；或者用上下文的rax寄存器来传递，反正rax本身就是用来传递参数的，只要在切换过程中不会破坏rax就可以了，实践证明是可行的。</p>
<p>不过传递还有一些问题，如果这个变量是指针？其实就不需要分配空间，直接用rax传递这个指针，如果是数组之类的，还需要做一些特化。</p>
<h2 id="copy_stack">copy stack</h2><p>协程栈也很有讲究。栈分很多中，平常使用的是静态栈，大小固定，缺点是浪费空间；segmented stack，按需分配，gcc支持；动态栈，栈不够用时重新分配一块，但是c++很难实现，因为只要有指向栈空间的指针，在移动之后就会立即失效；copy stack，用一个大的内存当做栈，用完之后把使用的栈保存到每一个协程。</p>
<p>这里就用了copy stack，每个协程保存一个栈基址，以及栈顶指针。另外定义一个大的公用栈，所有协程都用这一个共用栈；在使用之前，把协程栈的内容拷贝过去，用完再拷贝回来。</p>
<h2 id="lambda与函数指针">lambda与函数指针</h2><p>这算是一个小问题，就是如何拿到lambda的函数指针，看起来用target函数很容易拿到，但这里有一个坑：就算是用std::function<void()>保存的lambda，target<void(*)()>也是未必能拿到的函数指针的。这里还没有深入研究，我猜是因为target用了dynamic_cast，而那个指针其实是void (Lambda::<em>)(Lambda</em>)，成员函数指针，用户几乎不可能拿到啊，回头再研究一下。</void(*)()></void()></p>
<p>不过有一个解决方案，就是在std::function<void()>外面再套一层普通的函数，把这个函数指针当做ucontext的入口，然后把std::function<void()>当做参数传递给入口函数，这样就能解决lambda与函数指针之间的转换问题。</void()></void()></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>闲来无事，实现了一个协程。目前实现的特性有：</p>
<ol>
<li>手动yield、resume</li>
<li>支持在yield的时候传递变量</li>
<li>使用copy stack来减少协程的大小，目前每个协程需要1928B内存</li>
</ol>
<p>简]]>
    </summary>
    
      <category term="coroutine" scheme="http://wanghuanming.com/tags/coroutine/"/>
    
      <category term="协程" scheme="http://wanghuanming.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OS Kernel的简单实现]]></title>
    <link href="http://wanghuanming.com/2015/12/OS-Kernel%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanghuanming.com/2015/12/OS-Kernel的简单实现/</id>
    <published>2015-12-10T10:59:27.000Z</published>
    <updated>2015-12-10T13:09:14.284Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/kernel.jpg" alt=""></p>
<p>花了两个礼拜时间，大致实现了一个OS内核。总的过程还是蛮好玩的，从启动引导，到内核线程的创建，再到硬盘读写，学到了不少有意思的东西。不过在弄明白原理之后，剩下的基本都是比较枯燥的工作，自己也没什么心思再写下去，留下了一点遗憾。</p>
<p>目前这个内核实现了：</p>
<ul>
<li>引导启动</li>
<li>显示器输出</li>
<li>中断处理，包括键盘输入，定时器中断</li>
<li>物理内存管理：分页、分段</li>
<li>虚拟内存管理：二级页表、动态内存分配</li>
<li>内核线程，以及一个简单的线程调度器</li>
<li>IDE硬盘读写</li>
</ul>
<h2 id="运行环境">运行环境</h2><p>使用了qemu虚拟机，从一个软盘镜像启动，内核本身用grub加载。这个虚拟机非常轻量级，启动非常迅速，另外，它可以直接用gdb来调试，非常方便。</p>
<p>搭建环境的过程基本参考了Hurlex，所以在这里花了很少的时间。</p>
<h2 id="开发语言">开发语言</h2><p>Hurlex是用C完成的开发，但我在写C的过程中感觉非常不适，所以后来就采用C++开发。用C++开发倒没有什么大的问题，只是一开始犯了蠢，跟汇编交互的部分全都用了手动mangling，非常之痛苦。后来发现用extern “C”基本可以完成C++和汇编函数的交互，所以这个问题也不存在了。</p>
<p>用C++开发会有很多限制，比如标准库基本不能用，只能使用一部分语言特性。例如静态局部对象貌似就不太能用，因为这个会用到线程同步；全局对象也不太奏效，因为全局对象的初始化是依赖runtime的，这里只会为之分配内存，于.bss段，但不会执行初始化，所以还要手动初始化；说到手动初始化，比较好的方式是placement new，但kernel里也不能直接使用placement new，因为这是标准库的一部分。。</p>
<p>不过好在我们可以自己实现一个placement new：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(uint32_t count)</span> </span>&#123; <span class="keyword">return</span> kmalloc(count); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">uint32_t</span> count) &#123; <span class="keyword">return</span> kmalloc(count); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(uint32_t count, <span class="keyword">void</span>* ptr)</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">uint32_t</span> count, <span class="keyword">void</span>* ptr) &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span> </span>&#123; kfree(ptr); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr) &#123; kfree(ptr); &#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要这样简答的实现就好了，其余构造函数调用会由编译器来完成，我们也无能为力；这里调用的kmalloc/kfree是内存管理函数，所以这也意味着new/delete需要在完成虚拟内存管理模块之后才能使用。</p>
<p>C++在kernel中的限制基本就是内存上的限制，还有对象模型什么的，在<a href="http://wiki.osdev.org/C%2B%2B" target="_blank" rel="external">OSdev</a>上有讲述。另外，理论上讲是能够使用STL的容器的，但是我尝试使用了SGI STL，发现它还是有不少依赖，会由一些不兼容的部分，所以在kernel中就没有使用STL，自己写了一些非常bull shit的容器，因为完整地实现STL container工作量实在是比较大，哪天有空再去重构一下把。</p>
<p>除了这些限制之外，用C++开发能够获得这些好处：</p>
<ul>
<li>OO，容易进行模块化，比如Allocator，Scheduler</li>
<li>template，在实现printk函数的时候，使用变长模版参数会简化很多工作</li>
<li>reference，nullptr，type cast，default parameter什么的还是很方便的</li>
</ul>
<p>所以，我个人觉得C++写kernel会比较方便，如果能把STL的容器移植过去就更爽了。</p>
<h2 id="引导启动">引导启动</h2><p>由于用grub引导，所以稍微修改了一下grub的配置，把启动文件改成内核的名字。</p>
<p>内核的初始化，用汇编语言完成，设定一些Magic Number，栈地址，然后就跳到entry函数。</p>
<p>其实到这里内核就已经初始化了，我们可以在里面计算加减乘除什么的都没有问题，只是，目前没有IO，这个黑盒里的东西我们什么都看不到。迫在眉睫的事情就是让它能够显示什么东西出来。</p>
<h2 id="显示器输出">显示器输出</h2><p>显示器的输出也比较简单，地址空间的0xB8000是显存的起始地址，往后每两个字节对应屏幕上的一个字符，共80×25。两个字节，一个字节控制显示字符，另一个控制前景色和背景色。除此之外还有光标，这需要通过IO端口来完成。</p>
<p>我们基于此可以实现在屏幕上显示一个“hello world”，算是小有成就。</p>
<p>之后可以对此进行完善，实现颜色控制，屏幕滚动等功能。</p>
<h2 id="中断处理">中断处理</h2><p>中断，当CPU收到中断时，会检查idt指向的中断表，根据中断号执行到相应的ISR。</p>
<p>键盘中断，对应的中断号是33，通过0x60 IO口接收输入字符；键盘按下和释放都会触发一次。另外，向按键组合，都是需要程序的逻辑来实现。拿shift举例，按下shift的同时，再按其他的字符由小写变大写，大写变小写，所以我们需要至少两张字符映射表，shift键的按下与否需要维护，来实现按键组合的功能。</p>
<p>实现了键盘中断之后，我们就可以在屏幕上打字了。理论上讲我们已经有了输入输出，其实可以在此基础上写一个贪吃蛇什么都没有问题。</p>
<p>时钟中断是另一个重要的中断。CPU外部有多个定时器，可以通过编程的方式，让它们定时向CPU发出中断，于是kernel就有了时间的概念。之后的进程调度什么也会在此基础上进行。</p>
<h2 id="物理内存">物理内存</h2><p>内存管理是比较复杂的一块。</p>
<p>grub在加载内核时，一般是加载到0x100000的地址，也就是1M。低地址空间下会有很多外部设备，往上才是我们能够利用的空间。</p>
<p>如何使用这么多内存，是物理内存管理的主题。</p>
<p>分段，是80386时引入的一个技术，它使得16位的cpu能够使用20位的地址空间，并且也带来了权限管理、内存隔离的功能。不过现代的OS基本都绕过了分段机制，也就是把段基址都设为0，段长都设为0xFFFFFFFF，分段也就没什么用了。</p>
<p>分页，是把连续的内存分为很多页，通常为4K。</p>
<p>在此基础上，就有了很多内存分配技术，我只采用了比较简单的隐式链表。就是说，现在有一块很大的内存，我们在这一块内存的起始处拿一块作为block header，记录上块大小和分配状态。然后基于大小信息就可以寻找到下一个块了。在分配的时候，找到一个空闲快，然后把这个空闲块一分为二，前面一块分配出去，后面的继续保留。而在回收的时候，则需要合并前后的空闲块。</p>
<p>Linux内核中实现了一些更为复杂的算法，例如Buddy system：把所有的内存块都视为2的k次幂，分配的时候，如果没有合适的块，就把当前的块一分为二，大小一样；直到找到一个满足2^k-1 &lt;= size &lt;= 2^k块。在这个过程中，大的块会被切成很多小的块，放到多个bucket里。分配的时候查找这些bucket，会非常快，对于4G的内存，只需要32个bucket。回收内存的时候，除了把内存放回bucket里，还需要把小的块合并成大的，防止没有内存可用。</p>
<h2 id="虚拟内存">虚拟内存</h2><p>虚拟内存也是一个伟大的技术。</p>
<p>它所带来的功能，比如进程隔离、进程共享、权限管理、页面换出等等，都是一个成熟的OS必不可少的。</p>
<p>对于32位的kernel，每个进程能够使用的地址空间都是4G，每个进程都能访问到相同的地址，而这个地址自然是虚拟地址，通过虚拟内存技术，映射到不同的物理地址。</p>
<p>虚拟内存的实现需要OS和硬件来协作。MMU是负责地址翻译的硬件，它拿到一个虚拟地址，去查询页表，计算相应的物理地址，而这个页表，需要OS来创建，也就是说映射需要OS来维护。通常来说OS会采用多级页表，以实现更好的空间利用率。并用TLB来缓存。</p>
<p>不过这里比较复杂的一点是，系统启动时我们使用的是物理地址，开启分页模式后才进入虚拟地址，对于代码来说，它的地址需要变动吗？代码中使用的地址在编译时已经确定，而内核的加载地址就是0x100000，如果代码使用3G～4G的虚拟地址，必然就会存在冲突。所以这里的解决方案是，先做一个妥协，一部分代码采用0x100000以上的地址，它负责建立一个临时页表，把内核的加载部分以及3G以上的虚拟地址都映射到同一个物理地址，于是内核里的所有代码都能运行了；然后另一段代码使用3G～4G的地址空间，它来建立真正的页表。</p>
<p>这里使用了按需分页的技术，内核只固定分配很小的一段空间，其他的地址都在产生page_fault的时候才去分配。</p>
<p>在实现页目录的时候，有一点需要注意，页目录的PDE存放的是物理地址，但是在代码中却不能使用物理地址去操作，只能用虚拟地址，所以还要做一次转换。</p>
<h2 id="内核线程">内核线程</h2><p>内核线程。线程对应了一个函数调用栈，以及一组寄存器，作为它的上下文。所以创建一个线程，就是分配一个栈，以及它的上下文。对于这些信息会有一个封装结构，通常为task_struct，也就是PCB。我们把这个PCB存放在栈顶，不过这也意味着，如果爆栈，这些数据都会被破坏。</p>
<p>线程初始化很有意思：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span>* stack_top = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;((<span class="keyword">uint32_t</span>)new_task + STACK_SIZE);</span><br><span class="line">        *(--stack_top) = (<span class="keyword">uint32_t</span>)new_task-&gt;pid; <span class="comment">// the parameter to kthread_exit</span></span><br><span class="line">        *(--stack_top) = <span class="number">0</span>;                 <span class="comment">// return address above the kthread_exit frame</span></span><br><span class="line">        *(--stack_top) = (<span class="keyword">uint32_t</span>)kthread_exit;</span><br><span class="line">        *(--stack_top) = (<span class="keyword">uint32_t</span>)fn;</span><br></pre></td></tr></table></figure></p>
<p>以此把线程id，0，线程退出函数，以及线程入口函数push到栈里。这个结构需要跟线程上下文切换来一起看：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">switch_to:</span></span><br><span class="line">    <span class="comment">; the first function parameter</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">eax</span>, [<span class="literal">esp</span>+<span class="number">4</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> [<span class="literal">eax</span>+<span class="number">0</span>], <span class="literal">esp</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="literal">eax</span>+<span class="number">4</span>], <span class="literal">ebp</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="literal">eax</span>+<span class="number">8</span>], <span class="literal">ebx</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="literal">eax</span>+<span class="number">12</span>], <span class="literal">esi</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="literal">eax</span>+<span class="number">16</span>], <span class="literal">edi</span></span><br><span class="line">    <span class="keyword">pushf</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="literal">ecx</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="literal">eax</span>+<span class="number">20</span>], <span class="literal">ecx</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">; the second function parameter</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">eax</span>, [<span class="literal">esp</span>+<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">esp</span>, [<span class="literal">eax</span>+<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">ebp</span>, [<span class="literal">eax</span>+<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">ebx</span>, [<span class="literal">eax</span>+<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">esi</span>, [<span class="literal">eax</span>+<span class="number">12</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">edi</span>, [<span class="literal">eax</span>+<span class="number">16</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="literal">eax</span>, [<span class="literal">eax</span>+<span class="number">20</span>]</span><br><span class="line">    <span class="keyword">push</span> <span class="literal">eax</span></span><br><span class="line">    <span class="keyword">popf</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>这里的大部分代码都是切换上下文，没有什么大问题。不过在最后ret的时候，由于没有保存ebp，跳转的地址就是栈顶的地址，对于之前的栈结构来说，就是栈顶的fn，线程入口函数；对于中断上下文来说，栈顶则是保存的返回地址，所以用一个ret就可以实现统一。</p>
<p>栈上的第二个函数的kthread_exit，线程退出函数，函数fn执行完毕，kthread_exit会被当做返回地址来跳转，所以直接执行kthread_exit。</p>
<p>再网上，是一个0，暂时不说。最底下的是线程id，这是作为kthread_exit的函数参数，因此前面的那个0也显而易见，是作为kthread_exit函数帧的返回地址，不过它是线程的终结，没有返回地址，就用了一个0来代替。借此能够拿到最底下的函数参数。如果需要传递参数给fn函数，也可以把这个值改成参数。</p>
<h2 id="硬盘读写">硬盘读写</h2><p>通过Program IO的方式读写IDE接口硬盘，简单来说就是会有一组控制寄存器和数据寄存器，发一个命令，然后去IO端口拿数据。</p>
<p>在此之前需要用qemu-img创建一个硬盘镜像，并挂载上去。之后的过程也是比较顺利。</p>
<h2 id="一些遗憾">一些遗憾</h2><ul>
<li>由于是C、C++、assembly混杂，代码很多地方都写的比较乱，没有做好设计。特别是链表，写了一个非常bull shit的实现。</li>
<li>没有实现一些通用的数据结构，抽象做的很差</li>
<li>没有实现用户进程，没有实现系统调用，因此也没有在此基础上写一个shell什么的</li>
<li>没有实现文件系统</li>
<li>内存分配那块可以完善的地方还有很多，只实现了最简单的算法</li>
<li>没有实现通用的定时器，没有实现墙上时间</li>
<li>线程调度，没有实现挂起，resume</li>
<li>没有做内核同步</li>
<li>总之这个kernel的完成度很低</li>
</ul>
<h2 id="总结">总结</h2><p>虽然留了很多的遗憾，但是自己暂时没心思也没功夫写这个kernel了。</p>
<p>收获还是蛮多的，也长了不少见识，实践是最好的学习方式。</p>
<h2 id="链接">链接</h2><ul>
<li><a href="https://github.com/HelloCodeMing/Sprite" target="_blank" rel="external">Sprite</a><h2 id="参考资料">参考资料</h2></li>
<li><a href="http://wiki.0xffffff.org/posts/hurlex-1.html" target="_blank" rel="external">Hurlex</a></li>
<li><a href="https://www.gitbook.com/book/chyyuu/ucorebook/details" target="_blank" rel="external">Ucore</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/kernel.jpg" alt=""></p>
<p>花了两个礼拜时间，大致实现了一个OS内核。总的过程还是蛮好玩的，从启动引导，到内核线程的创建，再到硬盘读写，学到了不少有意思]]>
    </summary>
    
      <category term="OS" scheme="http://wanghuanming.com/tags/OS/"/>
    
      <category term="kernel" scheme="http://wanghuanming.com/tags/kernel/"/>
    
      <category term="内核" scheme="http://wanghuanming.com/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从LLVM IR看C++对象模型(二)]]></title>
    <link href="http://wanghuanming.com/2015/11/%E4%BB%8ELLVM-IR%E7%9C%8BC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E4%BA%8C/"/>
    <id>http://wanghuanming.com/2015/11/从LLVM-IR看C-对象模型-二/</id>
    <published>2015-11-12T10:49:59.000Z</published>
    <updated>2015-11-12T13:38:10.523Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/LLVM%20IR.png" alt="LLVM IR"></p>
<blockquote>
<p>前面的文章简单介绍了在LLVM IR的世界里C++对象模型是什么样子，本文继续介绍在多继承情况下的对象模型。</p>
</blockquote>
<h2 id="多继承">多继承</h2><h3 id="无虚函数">无虚函数</h3><p>首先看看没有虚函数的情况下多继承的情况，示例代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Genius &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Think</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"thinking"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iq_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"running"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> speed_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Scooby : <span class="keyword">public</span> Genius, <span class="keyword">public</span> Dog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Doo</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"dooing"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> tail_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Genius *g = <span class="keyword">new</span> Scooby();</span><br><span class="line">    Dog *d = <span class="keyword">reinterpret_cast</span>&lt;Dog*&gt;(g);</span><br><span class="line">    Scooby *s = <span class="keyword">static_cast</span>&lt;Scooby*&gt;(g);</span><br><span class="line">    g-&gt;Think();</span><br><span class="line">    d-&gt;Run();</span><br><span class="line">    s-&gt;Doo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Scooby 继承Genius和Dog，并含有自己的数据成员。编译一下得到IR：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%<span class="class"><span class="keyword">class</span>.<span class="title">Genius</span> =</span> <span class="class"><span class="keyword">type</span> &#123;</span> i32 &#125;</span><br><span class="line">%<span class="class"><span class="keyword">class</span>.<span class="title">Dog</span> =</span> <span class="class"><span class="keyword">type</span> &#123;</span> double &#125;</span><br><span class="line">%<span class="class"><span class="keyword">class</span>.<span class="title">Scooby</span> =</span> <span class="class"><span class="keyword">type</span> <span class="title">&lt;</span>&#123;</span> %<span class="class"><span class="keyword">class</span>.<span class="title">Genius</span>, [</span><span class="number">4</span> x i8], %<span class="class"><span class="keyword">class</span>.<span class="title">Dog</span>, <span class="title">i16</span>, [</span><span class="number">6</span> x i8] &#125;&gt;</span><br></pre></td></tr></table></figure></p>
<p>内存布局很简单，在Scooby对象中直接包含了Genius和Dog对象，并按照声明顺序排列，当然，在最后为了字节对齐，还加上了一段padding。</p>
<p>而成员函数也只是稀松平常，直接由对象指针调用：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call void <span class="variable">@_ZN6Genius5ThinkEv</span>(<span class="variable">%class</span>.Genius* <span class="variable">%10</span>)</span><br><span class="line">  <span class="variable">%11</span> = load <span class="variable">%class</span>.Dog<span class="variable">*,</span> <span class="variable">%class</span>.Dog<span class="variable">**</span> <span class="variable">%d</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  call void <span class="variable">@_ZN3Dog3RunEv</span>(<span class="variable">%class</span>.Dog* <span class="variable">%11</span>)</span><br><span class="line">  <span class="variable">%12</span> = load <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%s</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  call void <span class="variable">@_ZN6Scooby3DooEv</span>(<span class="variable">%class</span>.Scooby* <span class="variable">%12</span>)</span><br></pre></td></tr></table></figure></p>
<p>在没有虚函数的情况下，没有什么奇怪的事情发生。</p>
<h3 id="有虚函数">有虚函数</h3><p>示例代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Genius &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Think</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"thinking"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> iq_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"running"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> speed_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Scooby : <span class="keyword">public</span> Genius, <span class="keyword">public</span> Dog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Think</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"scooby is thinking"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">"scooby is running"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> tail_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Genius *g = <span class="keyword">new</span> Scooby();</span><br><span class="line">    Dog *d = <span class="keyword">static_cast</span>&lt;Scooby*&gt;(g);</span><br><span class="line">    g-&gt;Think();</span><br><span class="line">    d-&gt;Run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在多继承的情况下，对象还是需要和类信息绑定。Genius类有一个虚函数，Dog类也有一个虚函数，因此它们都会有一个虚函数表，而Scooby继承了它们，则需要有两个虚函数表，因此对象中也需要有两个虚表指针指向两个虚函数表。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%<span class="keyword">class</span>.<span class="type">Genius</span> = <span class="typedef"><span class="keyword">type</span> <span class="container">&#123; <span class="title">i32</span> (...)**, <span class="title">i64</span> &#125;</span></span></span><br><span class="line">%<span class="keyword">class</span>.<span class="type">Dog</span> = <span class="typedef"><span class="keyword">type</span> <span class="container">&#123; <span class="title">i32</span> (...)**, <span class="title">double</span> &#125;</span></span></span><br><span class="line">%<span class="keyword">class</span>.<span class="type">Scooby</span> = <span class="typedef"><span class="keyword">type</span> &lt;<span class="container">&#123; %<span class="title">class</span>.<span class="type">Genius</span>, %<span class="title">class</span>.<span class="type">Dog</span>, <span class="title">i16</span>, [6 <span class="title">x</span> <span class="title">i8</span>] &#125;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>内存布局没什么特别，还是Genius和Dog两个对象，下面来看看虚函数表的初始化：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@_ZTV6Scooby</span> = linkonce_odr unnamed_addr constant [<span class="number">7</span> x i8*] [i8* null, i8* null, i8* bitcast (void (%class.Scooby*)* <span class="variable">@_ZN6Scooby5ThinkEv</span> to i8*), i8* bitcast (void (%class.Scooby*)* <span class="variable">@_ZN6Scooby3RunEv</span> to i8*), i8* inttoptr (i64 -<span class="number">16</span> to i8*), i8* null, i8* bitcast (void (%class.Scooby*)* <span class="variable">@_ZThn16_N6Scooby3RunEv</span> to i8*)], comdat, align <span class="number">8</span></span><br><span class="line"><span class="variable">@_ZTV6Genius</span> = linkonce_odr unnamed_addr constant [<span class="number">3</span> x i8*] [i8* null, i8* null, i8* bitcast (void (%class.Genius*)* <span class="variable">@_ZN6Genius5ThinkEv</span> to i8*)], comdat, align <span class="number">8</span></span><br><span class="line"><span class="variable">@_ZTV3Dog</span> = linkonce_odr unnamed_addr constant [<span class="number">3</span> x i8*] [i8* null, i8* null, i8* bitcast (void (%class.Dog*)* <span class="variable">@_ZN3Dog3RunEv</span> to i8*)], comdat, align <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>比较意外的是，Scooby并没有采用两个虚函数表，事实上它把两个虚函数表拼在了一起，Genuis的部分在前面，Dog的部分在后面。这里还用了两个Run函数，之后再去考证。</p>
<p>看看Scooby的构造函数中对虚表指针的初始化：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define linkonce_odr void <span class="variable">@_ZN6ScoobyC2Ev</span>(<span class="variable">%class</span>.Scooby* <span class="variable">%this</span>) unnamed_addr #<span class="number">3</span> comdat <span class="keyword">align</span> <span class="number">2</span> &#123;</span><br><span class="line">  <span class="variable">%1</span> = alloca <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  store <span class="variable">%class</span>.Scooby* <span class="variable">%this</span>, <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%2</span> = load <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span></span><br><span class="line">  <span class="variable">%3</span> = bitcast <span class="variable">%class</span>.Scooby* <span class="variable">%2</span> to <span class="variable">%class</span>.Genius*</span><br><span class="line">  call void <span class="variable">@_ZN6GeniusC2Ev</span>(<span class="variable">%class</span>.Genius* <span class="variable">%3</span>) #<span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%4</span> = bitcast <span class="variable">%class</span>.Scooby* <span class="variable">%2</span> to i8*</span><br><span class="line">  <span class="variable">%5</span> = getelementptr inbounds i8, i8* <span class="variable">%4</span>, i64 <span class="number">16</span></span><br><span class="line">  <span class="variable">%6</span> = bitcast i8* <span class="variable">%5</span> to <span class="variable">%class</span>.Dog*</span><br><span class="line">  call void <span class="variable">@_ZN3DogC2Ev</span>(<span class="variable">%class</span>.Dog* <span class="variable">%6</span>) #<span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%7</span> = bitcast <span class="variable">%class</span>.Scooby* <span class="variable">%2</span> to i32 (...)<span class="variable">**</span>*</span><br><span class="line">  store i32 (...)<span class="variable">**</span> bitcast (i8<span class="variable">**</span> getelementptr inbounds ([<span class="number">7</span> x i8<span class="variable">*]</span>, [<span class="number">7</span> x i8<span class="variable">*]</span>* <span class="variable">@_ZTV6Scooby</span>, i64 <span class="number">0</span>, i64 <span class="number">2</span>) to i32 (...)<span class="variable">**</span>), i32 (...)<span class="variable">**</span>* <span class="variable">%7</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%8</span> = bitcast <span class="variable">%class</span>.Scooby* <span class="variable">%2</span> to i8*</span><br><span class="line">  <span class="variable">%9</span> = getelementptr inbounds i8, i8* <span class="variable">%8</span>, i64 <span class="number">16</span></span><br><span class="line">  <span class="variable">%10</span> = bitcast i8* <span class="variable">%9</span> to i32 (...)<span class="variable">**</span>*</span><br><span class="line">  store i32 (...)<span class="variable">**</span> bitcast (i8<span class="variable">**</span> getelementptr inbounds ([<span class="number">7</span> x i8<span class="variable">*]</span>, [<span class="number">7</span> x i8<span class="variable">*]</span>* <span class="variable">@_ZTV6Scooby</span>, i64 <span class="number">0</span>, i64 <span class="number">6</span>) to i32 (...)<span class="variable">**</span>), i32 (...)<span class="variable">**</span>* <span class="variable">%10</span></span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Scooby的子对象Genius和Dog的虚表指针分别指向了Scooby虚函数表的第二项和第六项，即Think函数和Run函数。它们的相对索引和Genius虚函数表相同。</p>
<p>接着来看看对Scooby函数的调用：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%15 = load %class.Genius<span class="keyword">*</span>, %class.Genius<span class="keyword">*</span><span class="keyword">*</span> %g, align 8</span><br><span class="line">  %16 = bitcast %class.Genius<span class="keyword">*</span> %15 to void (%class.Genius<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">  %17 = load void (%class.Genius<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span>, void (%class.Genius<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> %16</span><br><span class="line">  %18 = getelementptr inbounds void (%class.Genius<span class="keyword">*</span>)<span class="keyword">*</span>, void (%class.Genius<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span> %17, i64 0</span><br><span class="line">  %19 = load void (%class.Genius<span class="keyword">*</span>)<span class="keyword">*</span>, void (%class.Genius<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span> %18</span><br><span class="line">  call void %19(%class.Genius<span class="keyword">*</span> %15)</span><br></pre></td></tr></table></figure></p>
<p>对Scooby::Think函数的调用很简单，基于虚表指针寻址，找到Genuis虚函数表的第0项，就是Scooby::Think函数了。</p>
<p>而对Scooby::Run函数的寻址则要复杂一点：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  %<span class="number">6</span> = load %<span class="keyword">class</span>.Genius*, %<span class="keyword">class</span>.Genius** %g, align <span class="number">8</span></span><br><span class="line">  %<span class="number">7</span> = bitcast %<span class="keyword">class</span>.Genius* %<span class="number">6</span> to %<span class="keyword">class</span>.Scooby*</span><br><span class="line">  %<span class="number">8</span> = icmp eq %<span class="keyword">class</span>.Scooby* %<span class="number">7</span>, null</span><br><span class="line">  br i1 %<span class="number">8</span>, label %<span class="number">13</span>, label %<span class="number">9</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">9</span>                                       ; preds = %<span class="number">0</span></span><br><span class="line">  %<span class="number">10</span> = bitcast %<span class="keyword">class</span>.Scooby* %<span class="number">7</span> to i8*</span><br><span class="line">  %<span class="number">11</span> = getelementptr inbounds i8, i8* %<span class="number">10</span>, i64 <span class="number">16</span></span><br><span class="line">  %<span class="number">12</span> = bitcast i8* %<span class="number">11</span> to %<span class="keyword">class</span>.Dog*</span><br><span class="line">  br label %<span class="number">13</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">13</span>                                      ; preds = %<span class="number">9</span>, %<span class="number">0</span></span><br><span class="line">  %<span class="number">14</span> = phi %<span class="keyword">class</span>.Dog* [ %<span class="number">12</span>, %<span class="number">9</span> ], [ null, %<span class="number">0</span> ]</span><br><span class="line">  store %<span class="keyword">class</span>.Dog* %<span class="number">14</span>, %<span class="keyword">class</span>.Dog** %d, align <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>首先需要调整this指针，让它指向Scooby的Dog子对象，然后查找Scooby::Run函数：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%20 = load %class.Dog<span class="keyword">*</span>, %class.Dog<span class="keyword">*</span><span class="keyword">*</span> %d, align 8</span><br><span class="line">  %21 = bitcast %class.Dog<span class="keyword">*</span> %20 to void (%class.Dog<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">  %22 = load void (%class.Dog<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span>, void (%class.Dog<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> %21</span><br><span class="line">  %23 = getelementptr inbounds void (%class.Dog<span class="keyword">*</span>)<span class="keyword">*</span>, void (%class.Dog<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span> %22, i64 0</span><br><span class="line">  %24 = load void (%class.Dog<span class="keyword">*</span>)<span class="keyword">*</span>, void (%class.Dog<span class="keyword">*</span>)<span class="keyword">*</span><span class="keyword">*</span> %23</span><br><span class="line">  call void %24(%class.Dog<span class="keyword">*</span> %20)</span><br></pre></td></tr></table></figure></p>
<p>寻址方式不变，不过这时候找到的其实是<code>@_ZThn16_N6Scooby3RunEv</code>，这是它的定义：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">define linkonce_odr void <span class="variable">@_ZN6Scooby3RunEv</span>(<span class="variable">%class</span>.Scooby* <span class="variable">%this</span>) unnamed_addr #<span class="number">0</span> comdat <span class="keyword">align</span> <span class="number">2</span> &#123;</span><br><span class="line">  <span class="variable">%1</span> = alloca <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  store <span class="variable">%class</span>.Scooby* <span class="variable">%this</span>, <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%2</span> = load <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span></span><br><span class="line">  <span class="variable">%3</span> = call i32 <span class="variable">@puts</span>(i8* getelementptr inbounds ([<span class="number">18</span> x i8], [<span class="number">18</span> x i8]* <span class="variable">@.</span>str<span class="number">.3</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define linkonce_odr void <span class="variable">@_ZThn16_N6Scooby3RunEv</span>(<span class="variable">%class</span>.Scooby* <span class="variable">%this</span>) unnamed_addr #<span class="number">0</span> comdat <span class="keyword">align</span> <span class="number">2</span> &#123;</span><br><span class="line">  <span class="variable">%1</span> = alloca <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  store <span class="variable">%class</span>.Scooby* <span class="variable">%this</span>, <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%2</span> = load <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span></span><br><span class="line">  <span class="variable">%3</span> = bitcast <span class="variable">%class</span>.Scooby* <span class="variable">%2</span> to i8*</span><br><span class="line">  <span class="variable">%4</span> = getelementptr inbounds i8, i8* <span class="variable">%3</span>, i64 -<span class="number">16</span></span><br><span class="line">  <span class="variable">%5</span> = bitcast i8* <span class="variable">%4</span> to <span class="variable">%class</span>.Scooby*</span><br><span class="line">  call void <span class="variable">@_ZN6Scooby3RunEv</span>(<span class="variable">%class</span>.Scooby* <span class="variable">%5</span>)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@_ZThn16_N6Scooby3RunEv</code>函数的功能是，把this指针移回Scooby对象的基址，然后调用真实的Scooby::Run函数。这里饶了一大圈，还是回到了Scooby对象基址，何苦呢？因为在对Scooby::Run函数寻址的时候，需要Dog子对象的虚表指针，所以要先把Scooby对象指针调整到Dog子对象，之后调用Scooby::Run，在这个函数里面，整个Scooby对象的数据成员都是可见的，所以必须把this指针指向Scooby对象的基址。</p>
<h3 id="对数据成员的寻址">对数据成员的寻址</h3><p>我们可以顺便看一下Clang是如何对数据成员进行寻址的，在Scooby::Run函数中加入以下几行代码：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, iq<span class="number">_</span>);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, speed<span class="number">_</span>);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, tail<span class="number">_</span>);</span><br></pre></td></tr></table></figure></p>
<p>编译得到：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">define linkonce_odr void <span class="variable">@_ZN6Scooby3RunEv</span>(<span class="variable">%class</span>.Scooby* <span class="variable">%this</span>) unnamed_addr #<span class="number">0</span> comdat <span class="keyword">align</span> <span class="number">2</span> &#123;</span><br><span class="line">  <span class="variable">%1</span> = alloca <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  store <span class="variable">%class</span>.Scooby* <span class="variable">%this</span>, <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%2</span> = load <span class="variable">%class</span>.Scooby<span class="variable">*,</span> <span class="variable">%class</span>.Scooby<span class="variable">**</span> <span class="variable">%1</span></span><br><span class="line"></span><br><span class="line">; Genius::iq_</span><br><span class="line">  <span class="variable">%3</span> = call i32 <span class="variable">@puts</span>(i8* getelementptr inbounds ([<span class="number">18</span> x i8], [<span class="number">18</span> x i8]* <span class="variable">@.</span>str<span class="number">.3</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  <span class="variable">%4</span> = bitcast <span class="variable">%class</span>.Scooby* <span class="variable">%2</span> to <span class="variable">%class</span>.Genius*</span><br><span class="line">  <span class="variable">%5</span> = getelementptr inbounds <span class="variable">%class</span>.Genius, <span class="variable">%class</span>.Genius* <span class="variable">%4</span>, i32 <span class="number">0</span>, i32 <span class="number">1</span></span><br><span class="line">  <span class="variable">%6</span> = load i64, i64* <span class="variable">%5</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%7</span> = call i32 (i8<span class="variable">*,</span> ...) <span class="variable">@printf</span>(i8* getelementptr inbounds ([<span class="number">4</span> x i8], [<span class="number">4</span> x i8]* <span class="variable">@.</span>str<span class="number">.4</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span>), i64 <span class="variable">%6</span>)</span><br><span class="line">  </span><br><span class="line">; Dog::speed_</span><br><span class="line">  <span class="variable">%8</span> = bitcast <span class="variable">%class</span>.Scooby* <span class="variable">%2</span> to i8*</span><br><span class="line">  <span class="variable">%9</span> = getelementptr inbounds i8, i8* <span class="variable">%8</span>, i64 <span class="number">16</span></span><br><span class="line">  <span class="variable">%10</span> = bitcast i8* <span class="variable">%9</span> to <span class="variable">%class</span>.Dog*</span><br><span class="line">  <span class="variable">%11</span> = getelementptr inbounds <span class="variable">%class</span>.Dog, <span class="variable">%class</span>.Dog* <span class="variable">%10</span>, i32 <span class="number">0</span>, i32 <span class="number">1</span></span><br><span class="line">  <span class="variable">%12</span> = load double, double* <span class="variable">%11</span>, <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%13</span> = call i32 (i8<span class="variable">*,</span> ...) <span class="variable">@printf</span>(i8* getelementptr inbounds ([<span class="number">4</span> x i8], [<span class="number">4</span> x i8]* <span class="variable">@.</span>str<span class="number">.4</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span>), double <span class="variable">%12</span>)</span><br><span class="line">  </span><br><span class="line">; Scooby::tail_</span><br><span class="line">  <span class="variable">%14</span> = getelementptr inbounds <span class="variable">%class</span>.Scooby, <span class="variable">%class</span>.Scooby* <span class="variable">%2</span>, i32 <span class="number">0</span>, i32 <span class="number">2</span></span><br><span class="line">  <span class="variable">%15</span> = load i16, i16* <span class="variable">%14</span>, <span class="keyword">align</span> <span class="number">2</span></span><br><span class="line">  <span class="variable">%16</span> = sext i16 <span class="variable">%15</span> to i32</span><br><span class="line">  <span class="variable">%17</span> = call i32 (i8<span class="variable">*,</span> ...) <span class="variable">@printf</span>(i8* getelementptr inbounds ([<span class="number">4</span> x i8], [<span class="number">4</span> x i8]* <span class="variable">@.</span>str<span class="number">.4</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span>), i32 <span class="variable">%16</span>)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑还是比较清晰的：查找Genius::iq<em>，地址不变，把this指针转为Genius*类型；查找Dog::speed</em>对象，首先把this指针指向Dog子对象，然后指针转为Dog*类型；查找Scooby::tail_，直接查找成员变量就好了。</p>
<h2 id="小结">小结</h2><p>多继承场景下的对象模型相对复杂，不过捋清楚之后还是比较清晰的。比较麻烦的是，每家编译器对多继承的实现都不太一样，Clang的实现已经和《深度探索C++对象模型》里的实现有了一些出入，所以就不能照本宣科了。j</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/LLVM%20IR.png" alt="LLVM IR"></p>
<blockquote>
<p>前面的文章简单介绍了在LLVM IR的世界里C++对象模型是什么样子，本文继续]]>
    </summary>
    
      <category term="C++" scheme="http://wanghuanming.com/tags/C/"/>
    
      <category term="LLVM" scheme="http://wanghuanming.com/tags/LLVM/"/>
    
      <category term="LLVM IR" scheme="http://wanghuanming.com/tags/LLVM-IR/"/>
    
      <category term="对象模型" scheme="http://wanghuanming.com/tags/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从LLVM IR看C++对象模型]]></title>
    <link href="http://wanghuanming.com/2015/11/%E4%BB%8ELLVM-IR%E7%9C%8BC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://wanghuanming.com/2015/11/从LLVM-IR看C-对象模型/</id>
    <published>2015-11-11T06:53:51.000Z</published>
    <updated>2015-11-11T10:32:25.050Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/LLVM%20IR.png" alt="LLVM IR"></p>
<h2 id="简介">简介</h2><p>C++对象模型指的是C++语言中的“对象”如何映射到低级语言，包括内存布局、成员函数调用等，也就是说，我们日常使用的类、继承、虚函数、多继承，它们在编译器中都会有一套映射到低级语言的模型，所以，这些高级特性并不是与生俱来的。</p>
<p>而了解对象模型的一个很好的方式便是看高级语言如何映射到低级语言。我们通常所说的低级语言便是汇编，但了解汇编的都知道，它的可读性很低，没有类型，全是基于寄存器、内存的计算。如果从汇编来看C++的对象模型，它们之间的跨度太大，很可能让人不知所云。本文所要采用的低级语言是LLVM IR，它是LLVM（Low Level Virtual Machine）项目所使用的Immediate Representation，高级语言会编译成LLVM IR，之后再编译成汇编，直到机器码。LLVM IR的特点是它的表示足够底层，能够表示绝大多数高级语言的特性，同时，它也具备不错的可读性（相对于汇编）。所以，用LLVM IR来看对象模型是一个不错的选择。</p>
<h2 id="准备工作">准备工作</h2><p>这里使用Clang编译器，它是LLVM的C/C++前端。从C++代码编译到LLVM IR，需要执行以下命令：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -emit-llvm -S -fno-exceptions -fno-rtti <span class="keyword">test</span>.<span class="keyword">cc</span></span><br></pre></td></tr></table></figure>
<p>这里使用了no-exceptions和no-rtti参数，屏蔽了异常处理和RTTI的信息，减少了噪声。如果有需要了解exception和RTTI也可以加上这两个参数看看效果。</p>
<h2 id="普通对象">普通对象</h2><p>首先看看普通对象，即仅有数据成员、非虚函数、无继承的对象。实例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal *a = <span class="keyword">new</span> Animal();</span><br><span class="line">    a-&gt;foo();</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的Animal类，内含几个成员变量，以及一个成员函数，在用Clang编译之后，会得到IR：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%class.Animal = type &#123; i8, i16, i32, double &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是类的成员变量，char映射到i8，即int8，short是i16，以此类推。但是在class.Animal中，并没有foo函数的身影，这说明，普通的成员函数和非成员函数并没有什么不同。接着我们找到函数foo的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define linkonce_odr <span class="keyword">double</span> @_ZN6Animal3fooEv(%<span class="keyword">class</span>.Animal* %<span class="keyword">this</span>) <span class="preprocessor">#<span class="number">0</span> comdat align <span class="number">2</span> &#123;</span></span><br><span class="line">  %<span class="number">1</span> = alloca %<span class="keyword">class</span>.Animal*, align <span class="number">8</span></span><br><span class="line">  store %<span class="keyword">class</span>.Animal* %<span class="keyword">this</span>, %<span class="keyword">class</span>.Animal** %<span class="number">1</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">2</span> = load %<span class="keyword">class</span>.Animal*, %<span class="keyword">class</span>.Animal** %<span class="number">1</span></span><br><span class="line">  %<span class="number">3</span> = getelementptr inbounds %<span class="keyword">class</span>.Animal, %<span class="keyword">class</span>.Animal* %<span class="number">2</span>, i32 <span class="number">0</span>, i32 <span class="number">3</span></span><br><span class="line">  %<span class="number">4</span> = load <span class="keyword">double</span>, <span class="keyword">double</span>* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line">  ret <span class="keyword">double</span> %<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数用define关键字定义，和高级编程语言有几分相似之处。忽略一些函数的属性，直接看函数名—@_ZN6Animal3fooEv，这是经过了mangling的之后的函数名，可以发现类名、函数名、参数都编码进去了。而括号中的自然是参数列表，一个class.Animal类型的指针，名为%this。我们原本的foo函数是没有参数的，到这里却有了一个Animal类指针的参数，这是因为这个函数要和对象关联到一起，必须把这个对象的指针传进去。接下来几行是对成员变量d的寻址：d的地址可以直接通过对象基址的偏移得到，即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span> = getelementptr inbounds %<span class="keyword">class</span>.Animal, %<span class="keyword">class</span>.Animal* %<span class="number">2</span>, i32 <span class="number">0</span>, i32 <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>这句的意思是先对this指针解引用，然后取第3个元素，便得到了d的地址。</p>
<p>这里顺便解释一下LLVM IR，它是一种SSA形式的IR，即所有变量都是不可变的。变量的命名用%开头，局部变量会从1开始递增下去。LLVM IR中的指令大多都是二元指令，并且包含类型。例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store %<span class="keyword">class</span>.Animal* %<span class="keyword">this</span>, %<span class="keyword">class</span>.Animal** %<span class="number">1</span>, align <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p> 这条store指令表示把%this变量的值存到%1变量中；load指令则是加载变量，返回结果。</p>
<h2 id="单继承">单继承</h2><p>接下来看看单继承情况下的对象模型。示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> d_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    d.Run();</span><br><span class="line">    d.Say();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存模型如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%<span class="keyword">class</span>.<span class="type">Animal</span> = <span class="typedef"><span class="keyword">type</span> <span class="container">&#123; <span class="title">i32</span> &#125;</span></span></span><br><span class="line">%<span class="keyword">class</span>.<span class="type">Dog</span> = <span class="typedef"><span class="keyword">type</span> <span class="container">&#123; %<span class="title">class</span>.<span class="type">Animal</span>, <span class="title">double</span> &#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>由于Dog继承了Animal，所以Dog对象中包含了一个Animal对象，以及Dog自己的成员。</p>
<p>对于成员函数的调用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() <span class="preprocessor">#<span class="number">0</span> &#123;</span></span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %d = alloca %<span class="keyword">class</span>.Dog, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">1</span></span><br><span class="line">  %<span class="number">2</span> = bitcast %<span class="keyword">class</span>.Dog* %d to %<span class="keyword">class</span>.Animal*</span><br><span class="line">  %<span class="number">3</span> = call i32 @_ZN6Animal3RunEv(%<span class="keyword">class</span>.Animal* %<span class="number">2</span>)</span><br><span class="line">  %<span class="number">4</span> = call <span class="keyword">double</span> @_ZN3Dog3SayEv(%<span class="keyword">class</span>.Dog* %d)</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define linkonce_odr i32 @_ZN6Animal3RunEv(%<span class="keyword">class</span>.Animal* %<span class="keyword">this</span>) <span class="preprocessor">#<span class="number">0</span> comdat align <span class="number">2</span> &#123;</span></span><br><span class="line">  %<span class="number">1</span> = alloca %<span class="keyword">class</span>.Animal*, align <span class="number">8</span></span><br><span class="line">  store %<span class="keyword">class</span>.Animal* %<span class="keyword">this</span>, %<span class="keyword">class</span>.Animal** %<span class="number">1</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">2</span> = load %<span class="keyword">class</span>.Animal*, %<span class="keyword">class</span>.Animal** %<span class="number">1</span></span><br><span class="line">  %<span class="number">3</span> = getelementptr inbounds %<span class="keyword">class</span>.Animal, %<span class="keyword">class</span>.Animal* %<span class="number">2</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span></span><br><span class="line">  %<span class="number">4</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  ret i32 %<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define linkonce_odr <span class="keyword">double</span> @_ZN3Dog3SayEv(%<span class="keyword">class</span>.Dog* %<span class="keyword">this</span>) <span class="preprocessor">#<span class="number">0</span> comdat align <span class="number">2</span> &#123;</span></span><br><span class="line">  %<span class="number">1</span> = alloca %<span class="keyword">class</span>.Dog*, align <span class="number">8</span></span><br><span class="line">  store %<span class="keyword">class</span>.Dog* %<span class="keyword">this</span>, %<span class="keyword">class</span>.Dog** %<span class="number">1</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">2</span> = load %<span class="keyword">class</span>.Dog*, %<span class="keyword">class</span>.Dog** %<span class="number">1</span></span><br><span class="line">  %<span class="number">3</span> = getelementptr inbounds %<span class="keyword">class</span>.Dog, %<span class="keyword">class</span>.Dog* %<span class="number">2</span>, i32 <span class="number">0</span>, i32 <span class="number">1</span></span><br><span class="line">  %<span class="number">4</span> = load <span class="keyword">double</span>, <span class="keyword">double</span>* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line">  ret <span class="keyword">double</span> %<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于Animal类和Dog类的两个成员函数Run和Say，也是分别编译为两个独立的函数，只是传入的this指针有所区别。在对成员变量的寻址时，也是根据基址加偏移来计算。</p>
<h2 id="包含虚函数的单继承">包含虚函数的单继承</h2><p>C++在实现虚函数的时候，用了虚函数表的机制，把对象和函数绑定在一起。试想一下，我们拿到了一个Animal类型的指针，它可能会指向Animal对象，也可能指向继承Animal的Dog对象，这两个对象拥有不同的Say函数，我们想要达到的目的是，如果对象是Animal，则调用Animal::Say；如果对象时Dog，则调用Dog::Say。为了达到这个目的，对象的类型信息必须写到对象所占据的内存中，以实现把函数和对象绑定的目的。C++为了实现这一特性，使用了虚函数表这一技术：在每个对象中加入一个虚函数表指针，指向这个类的虚函数表；而虚函数表中则包含了类所具有的虚函数。因此通过对象基址和相对偏移就可以计算出相应的虚函数的地址了。</p>
<p>示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog: <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal *a = <span class="keyword">new</span> Dog();</span><br><span class="line">    a-&gt;Say();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译得到的IR如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%<span class="class"><span class="keyword">class</span>.<span class="title">Animal</span> =</span> <span class="class"><span class="keyword">type</span> &#123;</span> i32 (...)**, i16, [<span class="number">6</span> x i8] &#125;</span><br><span class="line">%<span class="class"><span class="keyword">class</span>.<span class="title">Dog</span> =</span> <span class="class"><span class="keyword">type</span> <span class="title">&lt;</span>&#123;</span> %<span class="class"><span class="keyword">class</span>.<span class="title">Animal</span>, <span class="title">i32</span>, [</span><span class="number">4</span> x i8] &#125;&gt;</span><br><span class="line"></span><br><span class="line">@_ZTV3Dog = linkonce_odr unnamed_addr constant [<span class="number">3</span> x i8*] [i8* <span class="literal">null</span>, i8* <span class="literal">null</span>, i8* bitcast (i32 (%<span class="class"><span class="keyword">class</span>.<span class="title">Dog*</span>)<span class="title">*</span> <span class="title">@_ZN3Dog3SayEv</span> <span class="title">to</span> <span class="title">i8*</span>)], <span class="title">comdat</span>, <span class="title">align</span> 8</span><br><span class="line"></span>@_ZTV6Animal = linkonce_odr unnamed_addr constant [<span class="number">3</span> x i8*] [i8* <span class="literal">null</span>, i8* <span class="literal">null</span>, i8* bitcast (i32 (%<span class="class"><span class="keyword">class</span>.<span class="title">Animal*</span>)<span class="title">*</span> <span class="title">@_ZN6Animal3SayEv</span> <span class="title">to</span> <span class="title">i8*</span>)], <span class="title">comdat</span>, <span class="title">align</span> 8</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到在%class.Animal中包含了一个指针，这就是虚表指针，解引用之后可到虚表的地址，虚表看做一个数组，数组中包含了函数指针，所以<code>i32 (...)**</code>会有两层指针。%class.Dog对象直接包含了Animal对象。</p>
<p>下面两行则是对虚表的初始化，Dog和Animal的虚表都在第三个位置存入了一个函数指针，分别是Dog::Say和Animal::Say。</p>
<p>至于对虚函数的调用，则需要通过对象基址，找到虚表指针，然后解引用找到虚表，再找到对应的函数：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="decorator">%6</span> = load <span class="decorator">%class</span>.Animal*, <span class="decorator">%class</span>.Animal** <span class="decorator">%a</span>, align <span class="number">8</span>                                     ; find vptr</span><br><span class="line"><span class="decorator">%7</span> = bitcast <span class="decorator">%class</span>.Animal* <span class="decorator">%6</span> <span class="keyword">to</span> i32 (<span class="decorator">%class</span>.Animal*)***                                 ; type <span class="keyword">cast</span></span><br><span class="line"><span class="decorator">%8</span> = load i32 (<span class="decorator">%class</span>.Animal*)**, i32 (<span class="decorator">%class</span>.Animal*)*** <span class="decorator">%7</span>                              ; dereference vptr, get virtual <span class="keyword">function</span> table</span><br><span class="line"><span class="decorator">%9</span> = getelementptr inbounds i32 (<span class="decorator">%class</span>.Animal*)*, i32 (<span class="decorator">%class</span>.Animal*)** <span class="decorator">%8</span>, i64 <span class="number">0</span>       ; retrieve <span class="keyword">function</span> from <span class="keyword">function</span> table</span><br><span class="line"><span class="decorator">%10</span> = load i32 (<span class="decorator">%class</span>.Animal*)*, i32 (<span class="decorator">%class</span>.Animal*)** <span class="decorator">%9</span>                               ; dereference entity <span class="keyword">in</span> <span class="keyword">function</span> table, get <span class="keyword">function</span> pointer</span><br><span class="line"><span class="decorator">%11</span> = call i32 <span class="decorator">%10</span>(<span class="decorator">%class</span>.Animal* <span class="decorator">%6</span>)                                                     ; call <span class="keyword">function</span> via <span class="keyword">function</span> pointer</span><br></pre></td></tr></table></figure>
<p>我在右边写了注释，简单解释了计算虚函数的过程。</p>
<h2 id="小结">小结</h2><p>普通对象，单继承，包含虚函数的单继承都是最最基本的OO，实现也相对简单，而C++中还有多继承，虚继承，这几个特性实现起来相对复杂，且看下回分解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7ktrkd.com1.z0.glb.clouddn.com/LLVM%20IR.png" alt="LLVM IR"></p>
<h2 id="简介">简介</h2><p>C++对象模型指的是C++语言中的“对象”如何映射到低级语言，包括]]>
    </summary>
    
      <category term="C++" scheme="http://wanghuanming.com/tags/C/"/>
    
      <category term="LLVM" scheme="http://wanghuanming.com/tags/LLVM/"/>
    
      <category term="LLVM IR" scheme="http://wanghuanming.com/tags/LLVM-IR/"/>
    
      <category term="对象模型" scheme="http://wanghuanming.com/tags/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Traits and mixin]]></title>
    <link href="http://wanghuanming.com/2015/11/Traits-and-mixin/"/>
    <id>http://wanghuanming.com/2015/11/Traits-and-mixin/</id>
    <published>2015-11-10T02:20:55.000Z</published>
    <updated>2015-11-10T03:54:00.341Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自《Traits：Composable Units of Behaviour》by Nathanael Schärli, Stéphane Ducasse, Oscar Nierstrasz, and Andrew P. Black</p>
<p>这是我在学习Scala trait时看到的一篇paper，从理论上讲解了trait和mixin，也分析了多继承的一些问题，很有学习的价值</p>
</blockquote>
<h2 id="摘要">摘要</h2><p>尽管在面向对象编程语言的世界里，继承在构件重用机制里起了中流砥柱的作用，但它的一些变种，例如单继承、多继承、混入继承（mixin），却一直有着理论和实现上的种种问题。在这篇paper的第一部分，我们举例来说明这些问题。接着我们提出trait，一种简单的用于构建面向对象语言的组合模型（compositional model）。一个trait，其实就是一组方法的集合，它们是构建一个类的基本单元，也是代码重用的基本单元。在trait模型中，类由一组traits组成，以及包含一些胶水代码用于组合这些traits并记录状态。我们展示trait如何克服多继承、混入继承带来的问题，以及如何高效地实现trait，同时也总结了如何用trait来重构一个类层次（class hierarchy）。</p>
<h2 id="介绍">介绍</h2><p>尽管单继承被广泛认为是面向对象的必要元素，程序员却渐渐意识到单继承在很多时候不能够有效地从一个复杂的类结构中提取出共用特性（变量和方法）。所以，语言的设计者们提出了多种多继承的机制，以及混入继承的机制，使得一个类能够从一系列的特征构建起来。</p>
<p>但将近二十年过去了，并没有什么多继承或混入继承获得广泛认可。在总结Alan Snyder于OOPSLA 87的会议上对于继承模式的贡献时，Steve Cook写到:</p>
<p>“多继承确实有价值，但没有好的实现方式。”</p>
<p>所以，总的趋势离多继承越来越远：最近的一些编程语言例如Java和C#的设计者认为，多继承带来的复杂性远比它的实际价值要大。而多继承确实也存在一些实现上的问题，我们也确信，它同样存在理论上的问题。在对这个问题进行研究之后，我们提出了trait的设计。</p>
<p>尽管多继承使得能够重用任何类，但类并不是合适的重用单元。这是因为类其实扮演了两个相互矛盾的角色，类既扮演了对象产生者的角色（类可以实例化成一个对象），因此它必须是完整的；但作为一个重用单元，一个类应当尽可能小。这些属性常常会引起冲突。此外，作为一个对象生产者，每个类需要在类层次结构有一个独一无二的位置，然而作为重用单元，类应该能够在任意位置。</p>
<p>Moon’Flavors（应该是一个冰淇淋）在早期提出这个问题：口味通常是一种很小的属性，并且也不需要是完整的，它可以混入到整个层次的任意位置。其他一些复杂的混入随后由Bracha、Cook、Mens、van Limberghen、Flatt、Krishnamurthi、Felleisen、Ancona、Lagorio、Zucca提出。这些方式允许程序员创建重用组件，但这些组件不需要被实例化。但是，据我们了解，这种方式会影响程序的可读性。</p>
<p>混入使用了单继承的符号，来把它扩展到多个基类。但是，尽管这个继承操作符适合从已有的类继承，它却不适合把多个重用组件组合到一起。特别是，使用继承来实现混入，使得混入必须被线性地组合起来，这严重地限制了使用胶水代码的能力，因为我们需要这些胶水代码来把混入合并到一起。</p>
<p>因此，我们提出了一种叫做traits的轻量级代码重用单元的概念。traits的设计从重用性和可读性的矛盾开始。总的来说，我们相信如果一个程序能够用多种形式来解读，它的可读性会更高。尽管一个类能够通过组合小的traits来构建，但我们其实可以用多种眼光来看待这个类。它可以被看作是一个扁平化的方法集合，或者是一个由traits组成的合成物。扁平化的视图有助于理解；而合成试图则有助于重用。到目前位置还没有什么冲突，这两种概念能够和平共处，不过有一个限制条件，这种组合必须只能作为一种架构工具，不会改变类的涵义。</p>
<p>traits刚好满足了这个条件。它为类提供了结构化、模块化、重用性，并且如果用类的眼光来看待，这些traits又可以被忽略掉。trait在重用性和可读性之间取得了一个完美平衡，同时也实现了更好的概念建模。并且，由于traits仅仅关心行为的重用性，并不关心状态的重用，这就避免了在多继承和混入中遇到的实现问题。</p>
<p>traits具有以下特性：</p>
<ul>
<li>一个trait提供了一系列的方法，并且包含实现（译者注：Java8之前的的interface不能包含实现）</li>
<li>一个trait需要一些方法作为参数，来获得提供的其他方法</li>
<li>traits不声明任何状态，其提供的方法也不会直接访问状态变量</li>
<li>类和traits能够由其他的traits合成，但合成顺序是不相干的。有冲突的方法必须要显式决议。</li>
<li>trait组合不影响一个类的涵义：这些从trait获得的方法，即便是直接定义在class中，也不会改变类的涵义</li>
<li>类似的，一个trait组合也不会影响trait的语义：一个组合trait，等价于把这些trait的方法直接写在这个组合trait里面</li>
</ul>
<p>一个类能够继承一个基类，然后添加一系列的traits，以及必要的状态变量和方法。这些添加的方式其实就是指定了traits如何连接到一起，如何解决它们之间的冲突。这种方式使得一个类能够由一系列的特性——traits，然后用一些胶水代码把这些特性组合到一起。由于一个方法的语义跟它定义在trait里或是定义在使用这个trait的类里无关，所以把一个组合的trait在任意层次扁平化都是没有问题的。</p>
<p>本文的贡献主要包括提出多继承和混入的问题，以及提出了traits这一组合模型来解决这些问题。我们遵循以下顺序：第二节描述了多继承和混入的问题，第三节提出traits以及一些样例。在第四节讨论了最重要的设计决策，并以此来解决第二节提出的问题。第五节提出了traits的实现。第六节总结了traits的现实应用：对Smalltalk-80集合框架的重构。第七节讨论相关工作。第八节对本文做了总结，并指出未来的工作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文翻译自《Traits：Composable Units of Behaviour》by Nathanael Schärli, Stéphane Ducasse, Oscar Nierstrasz, and Andrew P. Black</p>]]>
    </summary>
    
      <category term="OOP" scheme="http://wanghuanming.com/tags/OOP/"/>
    
      <category term="Programming" scheme="http://wanghuanming.com/tags/Programming/"/>
    
      <category term="Traits" scheme="http://wanghuanming.com/tags/Traits/"/>
    
      <category term="mixin" scheme="http://wanghuanming.com/tags/mixin/"/>
    
      <category term="Reading" scheme="http://wanghuanming.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[future/promise的简单实现]]></title>
    <link href="http://wanghuanming.com/2015/08/implementation%20of%20future/promise/"/>
    <id>http://wanghuanming.com/2015/08/implementation of future/promise/</id>
    <published>2015-08-22T02:33:39.000Z</published>
    <updated>2015-09-29T04:13:59.626Z</updated>
    <content type="html"><![CDATA[<p>之前看过很多次C++11 concurrency的API，但是还是不太明白期中的原理，而API的花样又很多，不同的语言有不同的API，在实际使用的时候还是很茫然。早上坐在窗口发呆的时候突然想明白future/promise模式，遂写下几行代码验证，果然是这么回事。</p>
<h2 id="概述">概述</h2><p>future/promise模式的设计目标是在多线程的场景下获得任务执行结果。例如，有下面这么一个任务：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    play_for_a_while();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个任务就是先去玩一会，然后返回一个1024。由于玩的时间会比较长，如果不想等待，我们可以把它放到另一个线程去跑：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread(task).detach();</span><br></pre></td></tr></table></figure></p>
<p>OK，这样子这个任务就可以在另一个线程执行，不会干扰我们的正常工作。</p>
<h2 id="如何获得执行结果">如何获得执行结果</h2><p>现在问题来了，如何获得这个任务的执行结果呢？</p>
<p>如果它只是一个函数，我们可以直接获得它的返回值；如果它是另一个线程上的函数，我们是不能拿到它的返回值的。这是因为一个线程对应了一个函数调用栈，任务线程和主线程使用的不是同一个函数调用栈；而函数返回值是依赖函数调用栈实现的（寄存器传值并不是通用的），所以这就好比任务线程和主线程根本不是一条路上的人，怎么能走到一起去呢？</p>
<h2 id="promise">promise</h2><p>所以，如果要把任务线程的结果传递给主线程，就需要一个中转站，任务执行完成后把结果放到中转站，然后主线程就去这个地方拿。中转站无疑是堆区内存了，这块空间由任务线程开辟，于是我们便得到了promise：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">promise</span><span class="params">(F task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">result_t</span> = <span class="keyword">decltype</span>(task());</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">result_t</span>&gt;();</span><br><span class="line">    <span class="built_in">std</span>::thread([=]&#123;</span><br><span class="line">        *ret = task();</span><br><span class="line">    &#125;).detach();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> res = promise([]&#123; <span class="keyword">return</span> <span class="number">1024</span>; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">100</span>ms);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *res &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑太简单，就不赘述了。promise函数返回一个智能指针，就是存放结果的地方。而主线程可以直接去这里拿到结果。但是这里的问题也显而易见，按理说我们应该在任务完成的时候才能去拿结果，这个时间点如何把控？</p>
<h2 id="future">future</h2><p>一种方式就是异步回调，但是一旦回调，所有的代码都会掉进这个坑里，并且我们之前写的promise也浪费了，所以我们采取一种同步的方式——等待任务完成。</p>
<p>当然，等待并不意味着低效，我们在等待的时候可以喝一杯咖啡什么的。现在我们需要去等待另一个线程的完成，这是不是需要用到condition_variable、信号之类的东西呢，其实也不需要，因为线程可以join嘛。在执行任务的时候不是把这个线程detach，而是交给主线程来join，不就完事了？当然，这是一个move的过程，因为thread不能复制。</p>
<p>由于需要把任务结果指针、任务线程都传给主线程，所以我们对此进行一个封装，于是得到了future：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">promise</span><span class="params">(F task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">result_t</span> = <span class="keyword">decltype</span>(task());</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">result_t</span>&gt;();</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="built_in">std</span>::thread([=]&#123;</span><br><span class="line">        *ret = task();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> future&lt;<span class="keyword">result_t</span>&gt;(ret, <span class="built_in">std</span>::move(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> future &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    future(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data, <span class="built_in">std</span>::thread&amp;&amp; t): </span><br><span class="line">        data_(data), t_(<span class="built_in">std</span>::move(t)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t_.join();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data_;</span><br><span class="line">    <span class="built_in">std</span>::thread t_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</span><br><span class="line">    </span><br><span class="line">    future&lt;<span class="keyword">int</span>&gt; fut = promise([]&#123; </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no, i'm sleeping\n"</span>;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hey, wake up\n"</span>;</span><br><span class="line">    fut.wait();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fut.get() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的输出如下：</p>
<blockquote>
<p>hey, wake up<br>no, i’m sleeping<br>1024</p>
</blockquote>
<h2 id="总结">总结</h2><p>future/promise到这里就差不多了，当然实现的细节还需要仔细考量，拷贝、移动之类的可能还需要写的更加完善一点。不过标准库的实现已经很不错了，也不必再去重复造轮子。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前看过很多次C++11 concurrency的API，但是还是不太明白期中的原理，而API的花样又很多，不同的语言有不同的API，在实际使用的时候还是很茫然。早上坐在窗口发呆的时候突然想明白future/promise模式，遂写下几行代码验证，果然是这么回事。</p>
]]>
    </summary>
    
      <category term="C++" scheme="http://wanghuanming.com/tags/C/"/>
    
      <category term="多线程" scheme="http://wanghuanming.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="异步编程" scheme="http://wanghuanming.com/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[并行容器的实现]]></title>
    <link href="http://wanghuanming.com/2015/07/implementation%20of%20parallel%20containers/"/>
    <id>http://wanghuanming.com/2015/07/implementation of parallel containers/</id>
    <published>2015-07-25T02:05:19.000Z</published>
    <updated>2015-07-25T03:42:55.563Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>之前说到functional-style容器，它最大的优势在于容易并行化。那么这里就简单地实现一下并行容器，以达到加速计算的目的。</p>
<p>先放一个性能测试的结果：<br><img src="http://7ktrkd.com1.z0.glb.clouddn.com/parallel-container-benchmark.png" alt="benchmark"></p>
<h2 id="并行容器">并行容器</h2><p>在functional-style的容器的基础上实现并行化还是比较简单的。例如我们要实现并行的foreach，那么就把整个区间切成几段，用几个线程去跑foreach。其他的函数实现也是类似。这里的一个前提是，计算结果要满足结合律。例如，我们对一个结合分4块做map，得到4个map结果，然后需要把结果合并在一起，这个前提就是集合可以合并；对一个集合做fold，得到4个fold的结果，也是需要满足结合律，而且这里比较特殊，fold的结果类型与init类型一致，如果init是整数，fold执行+操作，显然整数加法是满足结合律的；如果fold操作是减法，那就不满足了。</p>
<p>有了这个前提事情就比较好办了，我们先实现fold_if:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Init, <span class="keyword">class</span> Fn, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Combine&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fold_if</span><span class="params">(Init&amp;&amp; init, Fn f, Pred pred, Combine comb)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* the thread_num depends on the number of CPU cores */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> thread_num = sysconf(_SC_NPROCESSORS_ONLN);</span><br><span class="line">    <span class="keyword">auto</span> first = derived-&gt;begin();</span><br><span class="line">    <span class="keyword">auto</span> last = derived-&gt;end();</span><br><span class="line">    <span class="keyword">int</span> interval = <span class="built_in">std</span>::distance(first, last) / thread_num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::future&lt;Init&gt;&gt; fs(thread_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_num; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> start = <span class="built_in">std</span>::next(first, interval*i);</span><br><span class="line">        <span class="keyword">auto</span> end = (i == thread_num - <span class="number">1</span>) ? last : <span class="built_in">std</span>::next(start, interval);</span><br><span class="line">        fs[i] = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [=, init=<span class="built_in">std</span>::forward&lt;Init&gt;(init)]&#123;</span><br><span class="line">            Init res = init;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = start; i != end; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pred(*i))</span><br><span class="line">                    res = <span class="built_in">std</span>::move(f(<span class="built_in">std</span>::forward&lt;Init&gt;(res), *i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Init res = init;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : fs)</span><br><span class="line">        res = <span class="built_in">std</span>::move(comb(res, i.get()));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的fold_if与Iterable::fold_if签名不一样，因为执行分块fold_if之后，还有一个combine的步骤。对于fold来说，combine可以直接调用用户的functor，但是对于map，用户的functor却是对集合元素做映射，并非我们需要的combine。因此对这两种动作要区别对待，为fold_if增加了一个参数。</p>
<p>而combine动作，延续fold的传统（init = f(init, item))，不过这里的move尤其重要了。因为，combine的对象是集合，combine本身肯定会返回新的对象，不做move的话就会进行拷贝赋值，性能还是很低的。如果进行move，并且combine的动作执行<code>lhs += rhs</code>动作，那么就只有很小的开销了。测试证明，如果不做move，对于大的集合直接抛出std::bad_alloc。</p>
<h2 id="线程安全">线程安全</h2><p>这里似乎没有考虑线程安全的问题，因为代码中直接开了多个线程对iterator进行操作，没有线程同步之类的措施。事实上这里对容器的操作却恰好是线程安全的，因为我们把原容器当做immutable的，并没有对其进行写操作，而新容器只进行了串行的combine操作。多出来的开销是创建了一个新的容器，好处是轻松地实现线程安全的并行计算。</p>
<h2 id="性能提升">性能提升</h2><p>文章开头的那个图片就是一个简单的性能测试，在我的电脑（Intel Core i5-3230M）上测试开4个线程速度大约是串行的两倍。开始我还比较奇怪，因为我的电脑是双核4线程，按理说会有四倍的性能提升，但是开了4个线程却只有两倍的性能提升。后来查了一下超线程的相关资料，看来超线程并不能和真正的多核相比，所以得到的测试结果还是比较正常的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>之前说到functional-style容器，它最大的优势在于容易并行化。那么这里就简单地实现一下并行容器，以达到加速计算的目的。</p>
<p>先放一个性能测试的结果：<br><img src="http://7ktrkd.com1.]]>
    </summary>
    
      <category term="C++" scheme="http://wanghuanming.com/tags/C/"/>
    
      <category term="容器" scheme="http://wanghuanming.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="并行" scheme="http://wanghuanming.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++容器stream API的实现]]></title>
    <link href="http://wanghuanming.com/2015/07/stream%20api%20for%20C++%20container/"/>
    <id>http://wanghuanming.com/2015/07/stream api for C++ container/</id>
    <published>2015-07-07T11:53:17.000Z</published>
    <updated>2015-07-07T14:13:27.965Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>前面说到给C++实现了placeholder，以为C++就能变得函数式了，但事实上，它的用途还是很局限，因为每一个placeholder的功能都很小巧，只有当这些微小的部件组合在一起之后它才能发挥强大的功能。而函数式语言的容器通常都伴随着stream风格的API，使得对容器的操作能够行云流水地无缝衔接，而这正是C++所缺少的。所以在这里，我们来看看如何为C++的容器实现一个stream-API。</p>
<a id="more"></a>
<h2 id="stream">stream</h2><p>这里用的stream一词，是借用了java 8的stream。所谓stream，Oracle的文档是这样描述的：</p>
<blockquote>
<p>functional-style operations on streams of elements, such as map-reduce transformations on collections.</p>
</blockquote>
<p>这种范式来自于纯函数式编程语言，因为在纯函数式语言中，所有变量都是immutable，对容器进行udpate操作的唯一方式就是产生一个新的容器。这种编程范式在很多年里都没有成为主流，很大程度上应该还是机器性能的问题，相比于传统的方式它的开销要大的多。而近年来随着Google MapReduce编程模型的提出，函数式又成为并行计算的一个突破点。机器的性能够了，有4核，16核，甚至几百几万核，如何利用这些计算资源却成为一个问题。传统的多线程模型不容器实现并行程序，尤其是CPU bound的并行程序，而函数式的模型为此提供了一个很好的解法。</p>
<p>MapReduce的idea便是来源于函数式编程，它将一个大的计算任务分解成Map和Reduce操作（中间还有一个shuffle操作），而这两个操作是很容器并行的——因为它对所有数据的操作是一致的，只需要把任务分片，同时进行Map，同时进行Reduce，问题就得到了解决。当然，Spark将这一思想发挥到了极致，不仅是map，reduce，它将函数式语言的API都移植到了弹性分布式数据集（RDD）上，从而能够更加轻松地编写并行程序。例如，我们可以用一行代码对数据进行词频统计（word cound）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.textFile(<span class="string">"input"</span>).flatMap(_.split(<span class="string">" "</span>)).map(_ -&gt; <span class="number">1</span>).reduceByKey(_ + _).</span><br></pre></td></tr></table></figure>
<p>当然，编程效率的提高通常伴随着计算效率的降低，这是难以避免的。不过stream风格无疑是简洁，优雅的，这也是我要在C++里实现它的原因。</p>
<h2 id="C++_容器">C++ 容器</h2><p>C++中的容器和算法是分离的，中间通过iterator作为桥梁。</p>
<p>说实话我很欣赏这种设计，它达到了效率和代码重用性的极致。虽然我也喜欢stream风格的API，但很多时候它会造成容器API的膨胀，看看Scala每个容器都有30多个方法就会觉得一阵头晕。</p>
<p>但C++的容器算法有时候用起来并不是那么舒服，在我以前不理解C++的时候就经常感到疑惑，郁闷。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">std</span>::iota(vec.begin(), vec.end(), <span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::random_shuffle(vec.begin(), vec.end());</span><br><span class="line"><span class="built_in">std</span>::sort(vec.begin(), vec.end());</span><br></pre></td></tr></table></figure>
<p>可以看到，每个算法都需要传iterator进去，计算范围在begin在end之间，所以需要不断地重复begin、end，begin、end，如果直接传递容器进去不是干净利落？事实上并不能，因为你需要告诉算法你计算的范围，其他方式会更加恶心。那么在函数式语言中如何对容器进行部分操作呢，方法是把容器的部分元素“拿出来”——take、head、tail。</p>
<h2 id="stream_API的实现">stream API的实现</h2><p>扯淡了这么多，到这里要开始展现真正的技术了！</p>
<p>STL的容器有不少，包括vector、list、set、map、multiset、multimap、unordered_set、unordered_map，等等。并且，它们没有公共基类，我们也没办法对它们的代码做任何改动。so，要为它们增加方法必须是实现自己的容器。为了增加代码重用性，我们可以继承原有的容器，在此基础上扩展新的成员函数。为了避免代码膨胀，我们可以实现Iterable作为基类，让它实现一个基础的逻辑，而一些底层的成员函数则由派生类来实现。那么可以得到如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Iterable &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foreach</span><span class="params">(Fn f)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">map</span><span class="params">(Fn f)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Vector: <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, ming::Iterable&lt;T&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这里问题来了，Iterable需要调用由Vector实现的函数，按理说只要把那些函数都写成虚函数就可以了。但事实上并不行，因为有这么一条规则：模版函数不能是虚函数。因为模版函数是在调用的时候才会实例化，而虚函数需要借助virtual table来实现，virtual table需要是静态的。目前对这种问题编译器还没有一个好的解决方案，那么自然我们也就不能这样做了。</p>
<h3 id="CRTP">CRTP</h3><p>不过没关系，没有了动态多态，我们还有静态多态。C++有其特有的CRTP模式，能够实现这样的需求。所谓CRTP，就是派生类把自己的类型传递给基类，使得基类能够调用派生类的成员函数。这个过程看起来是本末倒置了，派生类继承了基类，又把自己传给基类，基类于是又能够访问派生类。但是在现有的编译模型下也只有这种做法了。</p>
<p>在调用派生类成员的时候，如果是静态成员，只需要<code>Derived::fun()</code>，而非静态成员则需要<code>static_cast&lt;Derived*&gt;(this)-&gt;fun()</code>，稍微麻烦了一点。我们可以顺手把这个指针变成基类的成员，调用起来会舒服一点。通过这种方式还能够享受到多继承的好处，基类Iterable不仅能够调用Vector的成员函数，还能调用std::vector的函数，甚至能调用自己的成员！这一切只需要通过<code>derived-&gt;fun()</code>就能达到！</p>
<p>虽然看起来很不可思议，但谁让Vector继承了std::vector和Iterable呢，所谓函数也不过是一个地址，而且这些函数都在Vector的命名空间下，理论上都能被Vector调用。这也算是意外之喜。</p>
<p>到这里理论上的问题已经被解决，可以开始动手实现了。我选择了fold作为基础函数，其他函数在它的基础上实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Init, <span class="keyword">class</span> Fn, <span class="keyword">class</span> Pred&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">fold_if</span><span class="params">(Init&amp;&amp; init, Fn f, Pred pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i: *derived) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pred(i))</span><br><span class="line">                init = f(<span class="built_in">std</span>::forward&lt;Init&gt;(init), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;Init&gt;(init);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Init, <span class="keyword">class</span> Fn&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">fold</span><span class="params">(Init&amp;&amp; init, Fn f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> derived-&gt;fold_if(<span class="built_in">std</span>::forward&lt;Init&gt;(init), f, [](<span class="keyword">auto</span>&amp;&amp; x)&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Fn&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">map</span><span class="params">(Fn f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> item_type = <span class="keyword">decltype</span>(f(head()));</span><br><span class="line">        <span class="keyword">using</span> container_type = <span class="keyword">typename</span> Derived::<span class="keyword">template</span> container&lt;item_type&gt;::type;</span><br><span class="line">        <span class="keyword">return</span> derived-&gt;fold(container_type(), [f](<span class="keyword">auto</span>&amp;&amp; init, <span class="keyword">auto</span>&amp;&amp; item) &#123;</span><br><span class="line">            init.add(f(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(item)&gt;(item)));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(init)&gt;(init);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">filter</span><span class="params">(Fn f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> derived-&gt;fold_if(Derived(), [](<span class="keyword">auto</span>&amp;&amp; init, <span class="keyword">auto</span>&amp;&amp; item) &#123;</span><br><span class="line">                init.add(item);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(init)&gt;(init);</span><br><span class="line">        &#125;, f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="map">map</h3><p>除了map其他几个函数都比较容易实现，而map的难度在于它的返回类型和容器未必是一样的，例如，如果map接受的是<code>map([](auto&amp;&amp; x) { return std::to_string(x); })</code>，那么容器的元素类型就会变成std::string了。</p>
<p>所以我们首先要推导map接受的callable的返回类型，再由此推导容器的类型。如果顺利的话，可以像这样是实现<code>Derived&lt;return_type&gt;</code>，但这显然不对，因为Derived的类型是Vecetor<t>，如果要替换必然涉及到模版形参的嵌套，这是违背C++语法的。</t></p>
<p>我就不卖关子了，这里用了“回调元函数”方式来实现这个功能，即在Vector中提供一个回调函数，当传入int的时候，返回Vector<int>。当然，这不是一个普通的函数，而是元函数。</int></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> container &#123;</span><br><span class="line">    <span class="keyword">using</span> type = Vector&lt;T&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然还有另一种风格，就是把回调组件分离出来得到container_traits，不过STL的容器并没有这样做，我也就直接把traits写在Vector里面了。</p>
<h3 id="添加元素">添加元素</h3><p>这里还有一个问题，不同的容器有不同的添加元素的方式，如何在Iterable里统一地执行呢。比较朴素的做法是每个派生类都实现一个add成员函数，以此来添加元素，vector用push_back，set用insert。</p>
<p>但我其实还有一种更加通用的做法。STL的容器添加元素的成员函数并不是无理无据的，像vector、list这种线性表用push_back，而set、map这样的树状结构则用insert，虽然命名不一样，但总的函数就那么几个。所以，能不能根据函数来选择呢，有push_back就用push_back，有insert就用insert。在java里用反射倒是容易实现，可以看到class的所有方法，但C++并没有反射，真的能做到这样吗。</p>
<p>其实也不是很难，静态判断有没有push_back而已，用SFINAE就能搞定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> has_push_back &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">class</span> C,</span><br><span class="line">        <span class="keyword">class</span> = <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;C&gt;().push_back(<span class="built_in">std</span>::declval&lt;Args&gt;()...))</span><br><span class="line">        &gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function">true_type <span class="title">check</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> C&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="function">false_type <span class="title">check</span><span class="params">(...)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> value = <span class="keyword">decltype</span>(check&lt;T&gt;(<span class="number">0</span>)&gt;::value;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">bool</span>, value&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>于是，实现这样一个add其实就没有问题了。</p>
<h3 id="Map">Map</h3><p>之前说完了map，现在要说Map。这个指的是Map容器，它的问题在于，map成员函数会得到不同的容器类型，例如，如果是<code>m.map(lambda(_.first * 2))</code>返回的结果就不是Map了，而是一个线性表，可以用Vector表示。那么这个类型要如何推导呢？</p>
<p>基本规则是，如果callable返回std::pair，容器类型就是Map<result_type>，否则就是Vector<result_type>。</result_type></result_type></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">map</span><span class="params">(Fn f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> result_type = <span class="keyword">decltype</span>(f(iterable::head()));</span><br><span class="line">        <span class="keyword">using</span> container_type = <span class="built_in">std</span>::<span class="keyword">conditional_t</span>&lt;</span><br><span class="line">                                            ming::is_pair&lt;result_type&gt;::value, </span><br><span class="line">                                            Map&lt;result_type&gt;, </span><br><span class="line">                                            Vector&lt;result_type&gt;&gt;;</span><br><span class="line">        <span class="keyword">return</span> iterable::fold(container_type(), [f](<span class="keyword">auto</span>&amp;&amp; init, <span class="keyword">auto</span>&amp;&amp; elem) &#123;</span><br><span class="line">                init.add(f(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(elem)&gt;(elem)));</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(init)&gt;(init);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用Map::map把Iterable::map覆盖掉就可以了。还是很轻松的。</p>
<h2 id="性能">性能</h2><p>到这里整个实现已经差不多了，细枝末节的东西我就不再这里赘述，可以直接看代码。但还有一个东西没有提及，就是性能。这样的实现会不会导致性能骤降呢，反复的拷贝，赋值，相比于原来的API性能会不会差太多呢。</p>
<p>如果是C++11以前，这样的实现很难避免低性能，或者说为了高性能实现起来有很大的难度。但有了移动语义的支持，再加上全局的完美转发，性能其实并不低。在我自己的测试下，对两百万个元素<code>map(_ * 2)</code>需要400ms，<code>filter(_ &lt; 10000)</code>需要40ms，foldeach和fold的时间也都是40ms左右，可以说这样的性能是相当不错的。所以在日常使用中使用这套容器是不会有太大的性能问题的。</p>
<h2 id="总结">总结</h2><p>花了大概两三天时间，摸索中搞定了这个东西，很多问题都是摸着石头过河，一边学习一边实践。其中学到了很多东西，例如SFINAE，constraints，自己之前学的TMP知识也全都用到了，函数式编程的知识也有所实践。并且算是搞懂了右值引用，移动语义，完美转发这些东西。收获颇丰。</p>
<p>之后还有进一步的开发计划，可能会实现并行集合，惰性集合，不过未来的事情谁会知道呢。</p>
<p>代码在<a href="https://github.com/HelloCodeMing/MyCppLibrary" target="_blank" rel="external">这里</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>前面说到给C++实现了placeholder，以为C++就能变得函数式了，但事实上，它的用途还是很局限，因为每一个placeholder的功能都很小巧，只有当这些微小的部件组合在一起之后它才能发挥强大的功能。而函数式语言的容器通常都伴随着stream风格的API，使得对容器的操作能够行云流水地无缝衔接，而这正是C++所缺少的。所以在这里，我们来看看如何为C++的容器实现一个stream-API。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://wanghuanming.com/tags/C/"/>
    
      <category term="Stream API" scheme="http://wanghuanming.com/tags/Stream-API/"/>
    
      <category term="functional" scheme="http://wanghuanming.com/tags/functional/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++占位符Lambda的实现]]></title>
    <link href="http://wanghuanming.com/2015/07/placeholder%20lambda%20for%20C++/"/>
    <id>http://wanghuanming.com/2015/07/placeholder lambda for C++/</id>
    <published>2015-07-03T10:20:13.000Z</published>
    <updated>2015-07-03T11:39:05.672Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>在很多函数式编程语言中都有着占位符表达式的语法，例如，Scala中可以写出这样的代码，<code>(1 to 10).map( _ + 1).foreach(println)</code>，其中，下划线<code>_</code>便代表了一个形参，<code>_ + 1</code> 可以得到一个<code>_ =&gt; _ + 1</code>这样的lambda表达式。占位符Lambda写起来要简洁，可读性也会更高，因此在现代函数式语言中得到了广泛的支持。</p>
<h2 id="C++_Lambda">C++ Lambda</h2><p>在C++11之前，Boost已经有了Lambda，并且功能很强大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(vec.begin(), vec.end(), _2 &gt; _1);</span><br></pre></td></tr></table></figure>
<p>有了占位符，我们再也不用为sort函数专门再写一个functor了。</p>
<p>不过占位符毕竟不是first-class citizen，有些场景它并不能应付：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="built_in">std</span>::for_each(vec.begin(), vec.end(), <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; _1 &lt;&lt; <span class="string">" "</span>);</span><br></pre></td></tr></table></figure>
<p>原因在于这个占位符是基于运算符重载的，不能应付那些复杂的表达式。</p>
<h2 id="实现占位符">实现占位符</h2><p>实现占位符的基本思路是这样的：占位符表达式的值是一个functor，或者是任何一个callable的东西；占位符本身需要是一个对象，并且重载了很多operator，其返回值是functor。</p>
<p>于是我们可以用C++14很轻松地写出支持<code>operator +</code> 的占位符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PlaceHolder &#123;</span><br><span class="line">&#125;_, _1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span> + (PlaceHolder lhs, T&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;x](<span class="keyword">auto</span>&amp;&amp; y) &#123; <span class="keyword">return</span> y +  <span class="built_in">std</span>::forward&lt;T&gt;(x); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意几点：1. 参数需要为右值引用并且要做forward以实现完美转发。2. lambda的参数需要为auto，因为运算符左右的类型可能并不一致。 3. lambda的参数也需要是右值引用。</p>
<p>接下来的工作就是重复性的了，我们需要重载所有的运算符，并且让运算符满足交换律。为了减少工作量，可以用宏来完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LAMBDA1_COMMUTATIVE_OPERATOR(OP) \</span><br><span class="line">    template &lt;class T&gt; \</span><br><span class="line">    auto operator OP (PlaceHolder, T&amp;&amp; x) &#123; \</span><br><span class="line">        return [&amp;x](auto&amp;&amp; y) &#123; return y OP std::forward&lt;T&gt;(x); &#125;; \</span><br><span class="line">    &#125; \</span><br><span class="line">    template &lt;class T&gt; \</span><br><span class="line">    auto operator OP (T&amp;&amp; x, PlaceHolder l) &#123; \</span><br><span class="line">        return l + x; \</span><br><span class="line">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>对占位符<code>_1</code>的支持已经基本结束，那么如何支持_2占位符呢。再来分析一下：表达式的值是functor，于是我们还是要重载operator，它的参数为两个PlaceHolder。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LAMBDA2_COMMUTATIVE_OPERATOR(OP) \</span><br><span class="line">    auto operator OP (PlaceHolder lhs, PlaceHolder rhs) &#123; \</span><br><span class="line">        return [](auto&amp;&amp; x, auto&amp;&amp; y) &#123; return x + y; &#125;; \</span><br><span class="line">    &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="缺陷">缺陷</h2><p>仔细想一下就可以发现，我们的占位符是用运算符重载实现的，那么对于非运算符表达式它就无能为力了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::for_each(vec.begin(), vec.end(), <span class="built_in">printf</span>(<span class="string">"wow%d\n"</span>, _1));</span><br></pre></td></tr></table></figure>
<p>那么我们试想一下，其他的函数式语言是如何实现这个东西的呢，其实再简单不过，只要在占位符表达式外面套一层lambda，把占位符作为参数传进去（我猜的）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_ % <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">&#123; _ =&gt; _ % <span class="number">2</span> + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">println(_)</span><br><span class="line">&#123; _ =&gt; println(_) &#125;</span><br></pre></td></tr></table></figure>
<p>其实C++11也有Lambda，但是语法不是那么简洁，并且C++又不是声明式语言，所有的返回值都要return，更是增加了语法的复杂性。上面这个表达式我们需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">auto</span> _) &#123; <span class="keyword">return</span> _% <span class="number">2</span> + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>在追求完美的路上我们不能就此停下脚步，于是，我们完全可以模仿转换的过程，为它写一个宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lambda(expr) \</span><br><span class="line">    [&amp;](auto&amp;&amp; _) &#123; \</span><br><span class="line">        return expr;  \</span><br><span class="line">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lambda2(expr) \</span><br><span class="line">    [&amp;](auto&amp;&amp; _1, auto&amp;&amp; _2) &#123; \</span><br><span class="line">        return expr; \</span><br><span class="line">    &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::for_each(vec.begin(), vec.end(), lambda(<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, _)));</span><br></pre></td></tr></table></figure>
<p>由于C++ Lambda不支持变长参数和缺省参数，我们只能给这个lambda手动重载，多取几个名字，不过这不影响美观。</p>
<p>除此之外，我们还意外地获得了另一种能力：传递函数模版。因为一般的函数模版不是一个类型，是不能当做变量传递的。经过lambda的封装之后，我们将得到一个真正的functor而不是一个模版！这不禁让我想起来<code>boost::mpl::lambda</code>。</p>
<p>到此已经基本结束，但实际上这个实现还是不完美。缺点我就不说了。</p>
<h2 id="代码">代码</h2><p>在我的<a href="https://github.com/HelloCodeMing/MyCppLibrary" target="_blank" rel="external">github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>在很多函数式编程语言中都有着占位符表达式的语法，例如，Scala中可以写出这样的代码，<code>(1 to 10).map( _ + 1).foreach(println)</code>，其中，下划线<code>_</code>便代表]]>
    </summary>
    
      <category term="C++" scheme="http://wanghuanming.com/tags/C/"/>
    
      <category term="Lambda" scheme="http://wanghuanming.com/tags/Lambda/"/>
    
      <category term="占位符" scheme="http://wanghuanming.com/tags/%E5%8D%A0%E4%BD%8D%E7%AC%A6/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逻辑运算符元函数的实现]]></title>
    <link href="http://wanghuanming.com/2015/06/implementation%20of%20logical%20operator%20in%20metaprogramming/"/>
    <id>http://wanghuanming.com/2015/06/implementation of logical operator in metaprogramming/</id>
    <published>2015-06-05T06:16:14.000Z</published>
    <updated>2015-06-11T04:47:21.762Z</updated>
    <content type="html"><![CDATA[<p>这是《C++ Template Metaprogramming》4-1的题目，要求实现一个logical_or和logical<em>and元函数，功能和mpl::or</em>等价，并且具有短路求值的性质。</p>
<p>也就是说，它需要保证以下测试能够通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Has no member "type", so will crash when obtaining Boom::type</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> Boom &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* logical or */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(logical_or&lt; true_,</span><br><span class="line">                          Boom&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">                        &gt;::value, <span class="string">"short circuit or boom"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;</span><br><span class="line">                logical_or&lt; true_, false_&gt;::type,</span><br><span class="line">                true_&gt;::value, <span class="string">"true_ and false_"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;</span><br><span class="line">                logical_or&lt; false_, true_&gt;::type,</span><br><span class="line">                true_&gt;::value, <span class="string">"false_ and true_"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;</span><br><span class="line">                logical_or&lt; false_, false_&gt;::type,</span><br><span class="line">                false_&gt;::value, <span class="string">"false_ and false_"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;</span><br><span class="line">                logical_or&lt; false_, false_, false_, true_&gt;::type,</span><br><span class="line">                true_&gt;::value, <span class="string">"false_ ,false_, false_, true_"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;</span><br><span class="line">                logical_or&lt; false_, false_, false_, false_&gt;::type,</span><br><span class="line">                false_&gt;::value, <span class="string">"false_, false_, false_, false_"</span>);</span><br></pre></td></tr></table></figure>
<p>期中比较重要的是第一条测试，它保证了短路求值，因为对第二个参数实例化的时候，logical_or会获取其type，而这并没有被Boom实现，所以编译不会通过。而在具有短路求值的情况下，第二个参数不会实例化，也就保证不会crash。</p>
<p>比较naive的实现是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1 = false_, <span class="keyword">class</span> T2 = false_, <span class="keyword">class</span> T3 = false_&gt;</span><br><span class="line"><span class="keyword">struct</span> naive_or &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> mpl::bool_&lt;T1::type::value || </span><br><span class="line">                                T2::type::value || </span><br><span class="line">                                T3::type::value&gt;::type type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> value = mpl::bool_&lt;T1::type::value || </span><br><span class="line">                                         T2::type::value || </span><br><span class="line">                                         T3::type::value&gt;::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>提供默认模版参数，用原生的||运算符实现逻辑，因为||是具有短路求值的性质的。但是，如果跑一下那个测试的例子，很容易发现它其实不能保证短路求值。因为到计算type的时候其实编译器已经把T1、T2、T3都实例化去求type了，所以会导致crash。</p>
<p>既然不能利用原生的||运算符，那我们剩下的就是用模版特化了。如果不需要计算type，我们很容易写出这样的特化版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1 = false_, <span class="keyword">class</span> T2 = false_, <span class="keyword">class</span> T3 = false_&gt;</span><br><span class="line"><span class="keyword">struct</span> logical_or &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;</span><br><span class="line"><span class="keyword">struct</span> logical_or&lt;true_, T2, T3&gt; &#123; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T3&gt;</span><br><span class="line"><span class="keyword">struct</span> logical_or&lt;false_, true_, T3&gt; &#123; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>但这样的偏特化缺陷在于不能求类型参数的type，或许，我们需要给它写一个wrapper做转发？那么wrapper应该要这样实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1 = false_, <span class="keyword">class</span> T2 = false_, <span class="keyword">class</span> T3 = false_&gt;</span><br><span class="line"><span class="keyword">struct</span> logical_or_wrap : logical_or&lt;<span class="keyword">typename</span> T1::type,</span><br><span class="line">                                                            <span class="keyword">typename</span> T2::type,</span><br><span class="line">                                                            <span class="keyword">typename</span> T3::type</span><br><span class="line">                                                            &gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很容易发现它的问题所在，这个wrapper还是去求type了，又会导致crash。</p>
<p>到了这里，我们应该能想到，我们实现的logical<em>or需要具备这样的性质：先看第一个参数，如果为true</em>， 结束匹配；否则继续看后面的类型。这样的性质如何满足？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1 = false_, <span class="keyword">class</span> T2 = false_, <span class="keyword">class</span> T3 = false_&gt;</span><br><span class="line"><span class="keyword">struct</span> logical_or2 : </span><br><span class="line">    mpl::eval_if&lt;T1,</span><br><span class="line">                          true_,</span><br><span class="line">                          logical_or2&lt;T2, T3&gt;&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> logical_or2&lt;&gt; : false_ &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>递归正好具有这样的性质，如果T1为true<em>, 设置值为true</em>；否则递归下去；同时还需要一个终结条件，就是最后两行代码。虽然这样的写法十分简洁明了，并且能够应付大部分场景，但唯一的不足就是它的参数有限，最好是我们具有一个无限长的参数列表。于是我们还需要把它写的更Robust一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Arg&gt; <span class="keyword">struct</span> logical_or: false_ &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Head, <span class="keyword">class</span> ...Tail&gt;</span><br><span class="line"><span class="keyword">struct</span> logical_or&lt;Head, Tail...&gt; :</span><br><span class="line">    mpl::eval_if&lt; Head, true_, logical_or&lt;Tail...&gt;&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写到这里，应该不能更完美了把！！！不过这里用到了eval_if，说不定我是利用了它的某些隐含的特性呢？为了证明我的清白，可以把这段代码写成self<em>contained。（除了true</em>，false_）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> Cond, <span class="keyword">class</span> Then, <span class="keyword">class</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> if_impl &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Then type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;classThen, Class Else&gt;</span><br><span class="line"><span class="keyword">struct</span> if_impl&lt;<span class="literal">false</span>, Then, Else&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Else type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Cond, <span class="keyword">class</span> Then, <span class="keyword">class</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> if_: if_impl&lt;Cond::value, Then, Else&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Cond, <span class="keyword">class</span> Then, <span class="keyword">class</span> Else&gt;</span><br><span class="line"><span class="keyword">struct</span> eval_if: if_&lt;Cond, Then, Else&gt;::type &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>好了，全部搞定。代码见<a href="https://github.com/HelloCodeMing/TMP/blob/master/chapter4/logical_or.hpp" target="_blank" rel="external">这里</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是《C++ Template Metaprogramming》4-1的题目，要求实现一个logical_or和logical<em>and元函数，功能和mpl::or</em>等价，并且具有短路求值的性质。</p>
<p>也就是说，它需要保证以下测试能够通过：</p>
<]]>
    </summary>
    
      <category term="C++" scheme="http://wanghuanming.com/tags/C/"/>
    
      <category term="MPL" scheme="http://wanghuanming.com/tags/MPL/"/>
    
      <category term="模版元编程" scheme="http://wanghuanming.com/tags/%E6%A8%A1%E7%89%88%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据流分析：数学原理]]></title>
    <link href="http://wanghuanming.com/2015/05/mathematica%20background%20for%20dataflow%20analysis/"/>
    <id>http://wanghuanming.com/2015/05/mathematica background for dataflow analysis/</id>
    <published>2015-05-29T03:09:10.000Z</published>
    <updated>2015-05-29T07:56:57.633Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>数据流分析是一种在编译时推断值在运行时流动的技术。通常，它会遍历控制流图，收集运行时信息，来为优化提供服务。在数据流分析的基础上，可以实施common-subexression elimination, constant propagation, dead-code elimination之类的优化，同时，它也是SSA（静态单赋值）形式的一个前提。</p>
<p>数据流分析牵扯到离散数学中的“偏序关系”和“格”的相关知识，而这些早已被我遗忘，为了搞明白这些问题，我还特地复习了离散数学，消耗了很多脑细胞。写下此文，祭奠我死去的脑细胞。</p>
<h2 id="数据流分析">数据流分析</h2><p>数据流分析的目的就是要搞清楚一个程序里数据的流向，从变量的定义到使用，为此，我们首先需要为这个问题建立一个模型。</p>
<p><img src="http://huanming-blog.qiniudn.com/图表1.png" alt="控制流图"></p>
<p>如图所示，为一个过程（procedure）画出它的控制流图。这里有两个概念：</p>
<ul>
<li>Basic Block：它指的是最长的无分支代码序列，如B1、B2</li>
<li>procedure：Basic Block的组合</li>
</ul>
<p>对于每个Block来说，它有输入和输出，定义为in[n], out[n]。对于一个Block来说，我们定义一个函数f来计算它的out[n]: $out[n] = f(in[n])$，我们把它称之为transfer function。那么这时候我们已经把Block内部的数据流向计算出来了。</p>
<p>而Block之间的数据流向呢？显然，如果一个结点只有一个前驱，它的输入就是前驱的输出，例如$in[2] = out[1]$。但是，如果这个结点有两个前驱呢，如B3？</p>
<p>这时候，我们定义一个运算符，$in[3] = out[2] \bigcup out[7]$，这个运算符同样适用于多个前驱的情况。我们把这个运算符称之为meet operator，但是需要注意的是它和我们俗称的“交”运算并不等价。</p>
<p>至此，我们建立的模型已经能够刻画在一个过程内的数据流向了：数据由顶端流入，经过Block的时候由transfer function映射，在Block之间由meet operator来计算。</p>
<p>不过在继续之前，我们先小结一些这里用到的一些概念和定义：</p>
<ol>
<li>Basic Block（Block）：不包含分支的最长代码序列</li>
<li>procedure：多个Basic Block的组合，也是一个连续的代码序列</li>
<li>in[n]： Block n的输入</li>
<li>out[n]: Block n的输出</li>
<li>transfer function：从in[n] 到 out[n] 的映射</li>
<li>meet operator：计算Block之间的数据流向，$in[n] = out[x] \bigcup out[y], x,y \in pred[n]$，</li>
</ol>
<h2 id="格">格</h2><p>（如果不需要证明迭代解法，此部分可以跳过，直接看迭代解法）</p>
<p>有了上面的模型，我们其实可以很容易发现，它和离散数学中的“格”非常像，我们再来回顾一下格(lattice)的概念。</p>
<p>格可以由偏序集（poset）定义，如果一个偏序集$ &lt; A, \leq &gt;$, 中的任意两个元素都有最小上界和最大下界，那么我们把它称之为格。在格中我们定义两个运算$\bigvee和\bigwedge$，对于任意的a，b，$a \bigvee b$表示a和b的最小上界，$a \bigwedge b$表示a和b的最大下界。并且，lattice满足以下定理：</p>
<ul>
<li>commutative: $a \bigwedge b = b \bigwedge a$</li>
<li>associative: $a \bigwedge ( b \bigwedge c) = ( a \bigwedge b ) \bigwedge c $</li>
<li>idempotent: $a \bigwedge a = a$</li>
<li>transitivity: $a \leq b, b \leq c \Rightarrow a \leq c$</li>
<li>antisymmetry: $a \leq b, b \leq a \Rightarrow a = b$</li>
<li>reflexitivity: $a \leq a$</li>
<li>$a \leq b \Leftarrow \Rightarrow a \bigwedge b = a$</li>
</ul>
<p>由最后一条定理其实我们也可以得到格的另一种定义方式：用meet operator去定义。只要满足$a \bigwedge b = a$即满足偏序关系，进而如果有最小上界和最大下界的话就是格了。</p>
<p>这样定义的意义在于，我们之前建立的模型，并没有用到偏序关系，只用到了meet operator，不过好在由于它们的等价性，我们还是得到了一个格。</p>
<p>等等，我们还没有证明之前的模型一定有上确界和下确界呢！是的，并且我们其实也无法证明，==！</p>
<p>不过可以肯定的是，这个过程只有一个入口，因此它是有上确界的，我们把这个模型叫做semi-lattice。（类似于群与半群的关系）</p>
<p>在得到我们的模型是semi-lattice的结论之后，同样也可以使用之前的几条性质，例如可交换、可结合、幂等、传递、反对称、自反。</p>
<h2 id="迭代解法">迭代解法</h2><p>然后，有了这些性质有什么用呢？我们的目的并不是为了这些性质，而是——求解方程。</p>
<p>之前得到的两个方程：</p>
<ul>
<li>$in[n] = out[x] \bigcup out[y], x, y \in pred[n] $</li>
<li>$out[n] = f(in[n])$</li>
</ul>
<p>利用这两个方程，如何求解数据才是最为关键的地方，再次重申我们的目标——计算每个Block的in和out。</p>
<p>不过到这里可能大家会有疑惑，方程中还有未知数f，以及meet operator，如何计算呢。这里其实不用着急，这两个变量因问题而异，不同的问题会有不同的transfer function和meet operator，这也是我们这两个方程的厉害之处——可以应付很多问题。所以在下面的讨论中，都假定$f$和$\bigcup$为已知量。</p>
<p>其实这个问题也已经显而易见了，从前往后递推呗。知道了B1的输入，就知道了B1的输出，进而确定B2和B4的输入，从而算出B3、B5、B6的输出……算B7输入的时候使用meet operator把B5和B6的输入统一起来。</p>
<p>很简单？如果只是纯数学的讨论，问题基本可以结束了。但是作为计算机科学的一个问题，我们还需要把这个算法形式化，至少要写出伪代码的。</p>
<p>大部分教科书都是使用的迭代法求不动点来求解这个问题，我们先来解释这个算法。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n &lt;- |N| - <span class="number">1</span></span><br><span class="line">changed &lt;- <span class="keyword">true</span></span><br><span class="line"><span class="keyword">while</span> (changed)</span><br><span class="line">    changed &lt;- <span class="keyword">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i &lt;- <span class="number">1</span> <span class="keyword">to</span> n</span><br><span class="line">        temp &lt;- <span class="comment">&#123;i&#125;</span> U f(<span class="keyword">in</span>[j]), <span class="keyword">for</span> j <span class="keyword">in</span> pred[i]</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="keyword">in</span>[i] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">out</span>[i] &lt;- temp</span><br><span class="line">            changed &lt;- <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>简单来说，就是不断迭代，应用以上的两个方程来计算out[n]，知道整个状态不变，我们也把这个状态称之为不动点（和Y combinator不一样)。并且，迭代时遍历的顺序不影响最后的结果，最多只影响算法效率。</p>
<h2 id="迭代解法的证明">迭代解法的证明</h2><p>我们之前只是给出了不动点算法的形式化描述，却没有证明它的正确性，比如，这个算法会停止吗，它是正确的吗，它的效率如何？</p>
<h3 id="convergence">convergence</h3><p>收敛性也就是可停止性，如果在迭代过程中集合不断收敛，必然会达到一个不动点。</p>
<p>我们来看transfer function，$out[n] = f(in[n])$，如果f是一个单调函数（monotone），那么要么out集合不断变小，或者不变，最后必然到达不动点；或者out集合不断变大或不变，最后由于整个输入数据是finite，也会导致收敛。那么我们只要证明它的单调性。</p>
<p>当然，f不可能在任意情况下都是单调的，因为这个函数是一个变量，我们需要证明的是它在特定情况下是单调的。</p>
<p>为了确定f的domain，我们把问题具象化，来考虑一下reaching definition的问题。</p>
<h4 id="reaching_definition">reaching definition</h4><p>这个问题说的是，一个变量在某一处的赋值，是否会直接影响到另一处的使用，如果能够影响，我们说这个definition 能够reach 某个使用。</p>
<p>在这个问题中，我们可以得到transfer function为$out[n] = gen[n] \bigcup ( in[n] - kill[n] )$。$gen$指的是Block中新生成的定义（赋值），$kill$指的是新的定义把旧的kill了。</p>
<p>对于这个transfer function，显然它是单调的，因为$in[a] \leq in[b] =&gt; gen[a] \bigcup (in[a] - kill[a]) \leq gen[b] \bigcup ( in[b] - kill[b]) $。这里就不证明了。</p>
<p>事实上对于这样的问题我们基本都能证明transfer function的单调性，进而收敛性也得到证明。</p>
<h3 id="correctness">correctness</h3><p>关于正确性，我们的计算在Block之内是满足方程$out[n] = f(in[n])$，关键是要证明meet operator是否能够推导出$temp &lt;= {i} \bigcup (\bigcap_{j\in preds(i)} in[j])$。这一点其实可以由meet operator的结合律和交换律已经幂等律得到保证，不作证明，请自行冥思。</p>
<h3 id="speed">speed</h3><p>速度的话，收敛速度取决于遍历的方式，最理想的遍历方式是在求一个out结点之前我们已经把它的predecessor都计算好了，但迭代算法显然不能达到。近似，我们可以采用Reverse Post Order（RPO）的顺序遍历，和后序遍历的顺序相反，从而尽量做到在访问一个结点之前先访问它的predecessor。</p>
<h2 id="递归算法？">递归算法？</h2><p>关于数据流分析的数学原理已经基本讲完，不过大家肯定会发现这并没有什么卵用——因为我们还没有把它的应用讲出来嘛，会在下一期讲述数据流分析的应用。</p>
<p>其实这个迭代不动点算法困扰我很久的原因在于，它用到了格的知识，但事实上这个格的知识只是为了证明算法的正确性。我们如果只想算出整个CFG的out集合，是不需要这些复杂的数学知识的。并且， 根据我的理解，也不需要迭代地计算这个问题，直接递归不就好了，并且也不需要证明它的正确性，递归算法完全符合方程的直观表示。</p>
<p>举例来说，我们定义一个IN函数来求in，那么$IN(n) = f(IN(x)) \bigcup f(IN(y))$，完全可以递归地去求解，为了效率的话还可以采取一定的记忆化措施，哪里需要什么迭代、不动点。说不定这些年来这个问题一直被复杂化了。。</p>
<p>当然，我还没从实践上证明递归的解法更加优秀，不过很快就会得到证明的。</p>
<h2 id="总结">总结</h2><p>花了好几天，终于搞定这个问题，收获还是蛮多的，复习了离散数学，看来接下来还要把图论再复习一下才能应付标量优化的部分。一开始看这个公式方程十分头疼，看多才总算找到门道。另外，数学总是能在我意想不到的地方给我致命一击，证明我的愚蠢，还是对当初没有好好学数学有一点点小遗憾的，不过好在时间还多，可以慢慢补回来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2><p>数据流分析是一种在编译时推断值在运行时流动的技术。通常，它会遍历控制流图，收集运行时信息，来为优化提供服务。在数据流分析的基础上，可以实施common-subexression elimination, constant propaga]]>
    </summary>
    
      <category term="数学" scheme="http://wanghuanming.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数据流分析" scheme="http://wanghuanming.com/tags/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/"/>
    
      <category term="编译优化" scheme="http://wanghuanming.com/tags/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"/>
    
      <category term="编译原理" scheme="http://wanghuanming.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="Reading" scheme="http://wanghuanming.com/categories/Reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LVN分析与实现]]></title>
    <link href="http://wanghuanming.com/2015/05/implementation%20of%20lvn/"/>
    <id>http://wanghuanming.com/2015/05/implementation of lvn/</id>
    <published>2015-05-22T11:32:16.000Z</published>
    <updated>2015-05-22T12:05:38.141Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>为了改进所生成代码的质量，优化编译器需要分析代码并且将其重写为一种更加高效的形式。根据优化范围的不同，可以分为局部优化，区域优化，全局优化，过程间优化。期中，局部优化指的是在一个最长的无分支代码序列中进行优化，它也被成为basic block。这是编译器能够使用的最简单的技术之一，但得到的效果却精准而高效。</p>
<p>局部优化中一种常见的优化就是冗余表达式消除，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line">d = b - c;</span><br><span class="line">c =b + c;</span><br><span class="line">d = b - c;</span><br></pre></td></tr></table></figure></p>
<p>表达式b+c同时出现在1和3中，并且b、c的值在此之间并没有改变，因此以上表达式可以优化成如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b + ;</span><br><span class="line">d = b - c;</span><br><span class="line">c = a;</span><br><span class="line">d = b - c;</span><br></pre></td></tr></table></figure></p>
<p>如此以来便可以减少一次加法运算。可能很多人说自己并不会写出这种冗余的表达式，但实际上这种冗余是很常见的，冗余表达式消除优化也也有它发挥的余地。</p>
<h2 id="LVN">LVN</h2><p>通常用于冗余表达式消除优化的算法是LVN（local value numbering），局部值编号。算法基于这样一种思想：</p>
<p>在上面的代码中，我们说第二次b+c是冗余的，是因为它的操作数并没有改变；而b-c虽然表达式重复，但并不冗余，因为在两次表达式之间包含一次对操作数的赋值，这可能会造成表达式的值改变。根本原因在于，变量值的改变。因此，我们需要通过某种手段，判断一个变量的值在是否被改变了。</p>
<p>为此，我们对每个变量进行编号，一旦它被重新赋值，我们会改变它的编号。得到以下的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a3 = b1 + c2;</span><br><span class="line">d4 = b1 - c2;</span><br><span class="line">c5 = b1 + c2;</span><br><span class="line">d6 = b1 - c5;</span><br></pre></td></tr></table></figure></p>
<p>从变量的编号可以很容易看出来，b+c的值没有变，而b-c的值已经变了。</p>
<p>接下来我们对这个算法进行形式化，使得它具有普适性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">construct a hash table</span><br><span class="line">for each operator in blocks: " Ti = Li Op Ri</span><br><span class="line">    1. get the value number for Li and Ri</span><br><span class="line">    2. construct a hash key for "Li Op Ri"</span><br><span class="line">    3. if the hash key in the table then:</span><br><span class="line">            <span class="operator"><span class="keyword">replace</span> the operation <span class="keyword">with</span> the <span class="keyword">value</span>  <span class="keyword">in</span> the <span class="keyword">table</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">insert</span> a <span class="keyword">new</span> <span class="keyword">value</span> <span class="built_in">number</span> <span class="keyword">into</span> the <span class="keyword">table</span> <span class="keyword">at</span> the <span class="keyword">hash</span> <span class="keyword">key</span> location</span><br><span class="line">            <span class="built_in">record</span> that <span class="keyword">new</span> <span class="keyword">value</span> nuber <span class="keyword">for</span> Ti</span></span><br></pre></td></tr></table></figure>
<h2 id="实现">实现</h2><p>实现放在了<a href="https://gist.github.com/HelloCodeMing/e927fe0c4b306b0a5d25" target="_blank" rel="external">Gist</a>上。</p>
<p>我这里从token流优化，相比于AST要困难一点，因为这个标号要从表达式的右边先编号，才能得到左边的编号，但token流是从左往右的，所以我这里先把表达式颠倒了一下，变成“c + c = a”，之后再把它反过来。</p>
<p>编号的过程中我用了两个表，一个记录变量的编号，另一个记录表达式的编号，理论上讲它们可以合在一起，但是由于我是基于token做的替换，那样就会存在一个变量和一个表达式具有相同的编号，反向查找的时候会发生一点冲突，所以还是分开来比较好。</p>
<p>另外，这里做的很不完备，基本只能跑我的demo，之后系统化地学完之后再把这些优化集成在一起，相信会非常强力的。</p>
<h2 id="总结">总结</h2><p>还有好多优化要学，好多优化。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="概述">概述</h2><p>为了改进所生成代码的质量，优化编译器需要分析代码并且将其重写为一种更加高效的形式。根据优化范围的不同，可以分为局部优化，区域优化，全局优化，过程间优化。期中，局部优化指的是在一个最长的无分支代码序列中进行优化，它也被成为basic bl]]>
    </summary>
    
      <category term="Compiler" scheme="http://wanghuanming.com/tags/Compiler/"/>
    
      <category term="LVN" scheme="http://wanghuanming.com/tags/LVN/"/>
    
      <category term="Optimization" scheme="http://wanghuanming.com/tags/Optimization/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LSRA分析与实现]]></title>
    <link href="http://wanghuanming.com/2015/05/implementation%20of%20LSRA/"/>
    <id>http://wanghuanming.com/2015/05/implementation of LSRA/</id>
    <published>2015-05-19T12:10:30.000Z</published>
    <updated>2015-05-19T23:51:41.976Z</updated>
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>LSRA是一种目前比较流行的寄存器分配算法，其算法简单，并且复杂度较小，相比于传统的图染色寄存器分配算法，更适合JIT编译器。本文分析并实现了LSRA算法。</p>
<h2 id="寄存器分配">寄存器分配</h2><h3 id="概述">概述</h3><p>寄存器分配是编译器后端的一个重要pass，主要目的在于把具有无限地址空间的虚拟寄存器分配到有限的寄存器集合。为了简化编译器前端的部分，大多数编译器使用的IR都是虚拟机寄存器集合，而在进行各趟优化之后，不论是基于寄存器的VM，还是普通的AOT编译器，都需要把虚拟寄存器映射到目标机的名字空间。</p>
<p>另一种不需要寄存器分配的是内存到内存的执行模型，例如jvm（符合jvm规范的）。众所周知，jvm采用的是单地址指令，如果执行“c = a + b”这样一行代码，得到的bytecode大概是“load a\n load b\nadd\n”，而在x86架构上三地址指令可能就是”add a b c”，可以看到内存到内存的模型代码相对紧凑，但是代码要长一点。据说jvm的作者因为不相信寄存器分配，所以采用了栈模型。而目前，众多的虚拟机都采用了寄存器模型，例如Lua vm、Dalvik，相比之下，采用寄存器模型的虚拟机在执行效率上可能会比栈模型要高一点，但是实现难度也相应要高一点。</p>
<p>一般来说，寄存器分配的目标是最小化逐出代码。当把无限名字空间映射到有限的空间时，通常会发生物理寄存器不够用的情况，这时候我们需要用load和store指令来把数据放到内存，这个动作也被称之为spill。而我们知道寄存器和内存的访问速度相差几个数量级，大量的load和store指令的插入会降低程序的执行速度，因此，寄存器分配器的设计目标就是最小化spill指令。</p>
<p>为了达到这个目标，我们首先需要明白，什么时候寄存器可以重用。</p>
<p>当寄存器中存储的一个变量的生命周期结束的时候，寄存器可以用作存储其他的变量，而在同一条指令中的使用到的几个寄存器，它们是有依赖关系的，显然不可以重复使用。换言之，如果两个变量在同一个时间点都在活动，它们就是有冲突的，不可以重用寄存器。为此，我们定义生存期的概念。</p>
<h3 id="LiveRange">LiveRange</h3><p>LiveRange指的是一个变量从第一次生命，到最后一次使用。如下图：<br><img src="http://huanming-blog.qiniudn.com/register_allocation_live_range.jpg" alt="Live Range"></p>
<p>a的LiveRange是0到4，e是1到3，。。。</p>
<p>而在同一个时间点，我们可以得到冲突的情况，例如，在timepoint 1处，a和e是冲突的，不能使用同一个寄存器。</p>
<h3 id="LiveAnalysis">LiveAnalysis</h3><p>由于得到这些冲突信息几乎是所有分配算法的前提，我们为这个动作专名取名为LiveAnalysis，生存期分析。在此之后才能进行其他的分析行为。</p>
<h2 id="图染色算法">图染色算法</h2><p>图染色算法基于这样一种思想，把这些冲突情况连成一张图，有冲突的变量之间连线。之后对整个冲突图进行染色，相邻的点之间用不同的颜色。能够让冲突图染色的最小颜色数既是最少使用的寄存器数量，染色即寄存器。</p>
<h2 id="LSRA">LSRA</h2><p>图染色算法可以得到很好的结构，但由于实现复杂，并且算法复杂度很高，并不适合动态编译的需要。因此LSRA（Linear Scan Register Allocation）算法应运而生，此算法基于一种简单的先到先的思想，先声明 的变量先得到寄存器，在发生spill的时候，选择占用寄存器时间最长的变量spill，spill的变量则插入load和store。算法复杂度很低，只需要进行一次扫描进行LiveAnalysis，在扫描每一个interval进行分配。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LinearScanRegisterAllocation</span><br><span class="line">    active ← <span class="comment">&#123;&#125;</span></span><br><span class="line">    foreach live interval i, <span class="keyword">in</span> <span class="keyword">order</span> <span class="keyword">of</span> increasing start point</span><br><span class="line">        ExpireOldIntervals(i)</span><br><span class="line">        <span class="keyword">if</span> length(active) = R <span class="keyword">then</span></span><br><span class="line">            SpillAtInterval(i)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">register</span>[i] ← a <span class="keyword">register</span> removed <span class="keyword">from</span> pool <span class="keyword">of</span> free registers</span><br><span class="line">            <span class="keyword">add</span> i <span class="keyword">to</span> active, sorted <span class="keyword">by</span> increasing <span class="keyword">end</span> point</span><br><span class="line">    </span><br><span class="line">ExpireOldIntervals(i)</span><br><span class="line">    foreach interval j <span class="keyword">in</span> active, <span class="keyword">in</span> <span class="keyword">order</span> <span class="keyword">of</span> increasing <span class="keyword">end</span> point</span><br><span class="line">        <span class="keyword">if</span> endpoint[j] ≥ startpoint[i] <span class="keyword">then</span></span><br><span class="line">        return</span><br><span class="line">    <span class="keyword">remove</span> j <span class="keyword">from</span> active</span><br><span class="line">    <span class="keyword">add</span> <span class="keyword">register</span>[j] <span class="keyword">to</span> pool <span class="keyword">of</span> free registers</span><br><span class="line">    </span><br><span class="line">SpillAtInterval(i)</span><br><span class="line">    spill ← last interval <span class="keyword">in</span> active</span><br><span class="line">    <span class="keyword">if</span> endpoint[spill] &gt; endpoint[i] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">register</span>[i] ← <span class="keyword">register</span>[spill]</span><br><span class="line">        location[spill] ← <span class="keyword">new</span> stack location</span><br><span class="line">        <span class="keyword">remove</span> spill <span class="keyword">from</span> active</span><br><span class="line">        <span class="keyword">add</span> i <span class="keyword">to</span> active, sorted <span class="keyword">by</span> increasing <span class="keyword">end</span> point</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        location[i] ← <span class="keyword">new</span> stack location</span><br></pre></td></tr></table></figure>
<p>上面的伪代码摘自LSRA的论文，期中interval和LiveRange概念相似，指的是一个变量的开始和结束。下面进行详述。</p>
<ol>
<li>进行LiveAnalysis，得到interval list</li>
<li>需要一个active list，保存当前活动的interval。</li>
<li>遍历每一个interval，首先查看active list中时候有interval过期，即变量死亡</li>
<li>接下来看时候有空闲的寄存器，如果有，给当前的变量分配一个寄存器</li>
<li>如果没有空闲的寄存器，则需要spill</li>
<li>spill：在active中找到结束时候最长的，与当前的interval比较，为先结束者分配寄存器，而将后结束者spill。</li>
</ol>
<h3 id="实现">实现</h3><ol>
<li><p>LLVM IR：这里写的LSRA基于LLVM IR，并且是human readable。而LLVM IR是SSA的，虚拟寄存器用“%1， %2，”表示，具有无限的命名空间，同时它也有named寄存器，“%x， %y”，直接代表变量。由于LLVM IR中没有esp这个概念，可以直接用named寄存器来存储变量，还是比较方便的。在spill的时候，用%tmp来充当临时寄存器保存中间值，用%s*存储变量指针。虽说LLVM IR是low level的，但其实用它来编程也是可以的，直接用lli执行，应该能极大地锻炼编程能力==！</p>
</li>
<li><p>replace：C++的regex居然不支持callback replace，花了很大的力气搞定这个问题。目前来说比较稳妥的方案是采用regex_token_iterator。</p>
</li>
</ol>
<ol>
<li><p>spill：spill的时候需要在当前指令之前插入load，之后插入store，而当前指令是拼起来的，这也就意味着store指令需要延迟插入，可以给store先声明一个占位符，之后检查这条指令是不是要插入；或者，像我这里采用的一个比较淫荡的写法：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; delay_fn;</span><br><span class="line">loop begin</span><br><span class="line">....</span><br><span class="line">    delay_fn = [=, &amp;res] &#123; res.push_back(<span class="string">"store i32 %tmp, i32*"</span> + <span class="keyword">register</span>); &#125;;</span><br><span class="line"><span class="function">loop end</span><br><span class="line"><span class="title">if</span> <span class="params">(delay_fn)</span> <span class="title">delay_fn</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p> 另外，需要注意capture的方式，loop作用域里的变量需要capture by value，因为一次loop之后这个变量就没有了。而loop之外的变量需要capture by reference，否则 push_back就没有意义了。</p>
</li>
<li><p>iota: c++11 为numeric增加了一个很好玩的iota，虽然简单不过很实用，即升序填充一个容器。据说这个一个希腊语的词。</p>
</li>
<li><p>code style：多层嵌套的条件结构或者循环结构，以及namespace，需要在右花括号处写上这个作用域的描述，例如“end namespace lsra”，这是应付嵌套过深的一个有效应对方案！</p>
</li>
<li><p>实现代码在<a href="https://github.com/HelloCodeMing/lsra" target="_blank" rel="external">我的github</a>。</p>
</li>
</ol>
<p>##　收获总结<br>一边学习LLVM，一遍实现期中的一些算法，还是挺有意思的。现阶段，看了LLVM的架构，看了scala-llvm的paper，一些高级语言的特性转换到LLVM IR很有意思。LLVM很大的优势在于解耦，将前端，优化，后端，统统分开，并且都做成库，极大地方便了用户使用，以及像我这样的初学者的学习。这样就可以一块块地看代码，不用面对一大坨的东西。</p>
<p>在实现LSRA的时候原本想基于LLVM bitcode，自己试着分析了一下它的编码，但觉得压力比较大，最后还是基于字符串的替换，相对简单。</p>
<h2 id="参考资料">参考资料</h2><ul>
<li><a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="external">LLVM IR reference</a></li>
<li><a href="http://www.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf" target="_blank" rel="external">LSRA</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="摘要">摘要</h2><p>LSRA是一种目前比较流行的寄存器分配算法，其算法简单，并且复杂度较小，相比于传统的图染色寄存器分配算法，更适合JIT编译器。本文分析并实现了LSRA算法。</p>
<h2 id="寄存器分配">寄存器分配</h2><h3 id="概述]]>
    </summary>
    
      <category term="LLVM" scheme="http://wanghuanming.com/tags/LLVM/"/>
    
      <category term="Register Allocation" scheme="http://wanghuanming.com/tags/Register-Allocation/"/>
    
      <category term="寄存器" scheme="http://wanghuanming.com/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    
      <category term="编译原理" scheme="http://wanghuanming.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现FTP协议]]></title>
    <link href="http://wanghuanming.com/2015/05/implement-ftp-protocol/"/>
    <id>http://wanghuanming.com/2015/05/implement-ftp-protocol/</id>
    <published>2015-05-08T10:53:19.000Z</published>
    <updated>2015-05-08T12:41:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>继续我的造轮子之路，花了一个礼拜时间，简单实现了一下FTP协议。自己真是菜啊，居然要写这么久。</p>
<h2 id="FTP协议概述">FTP协议概述</h2><p>FTP协议即文件传输协议，通常用于文件传输。它使用两个连接，一个控制连接，一个数据连接。通常FTP服务运行在21端口，20端口用于传输数据。对于客户端来说，有两种协商端口的方式，主动和被动：主动的情况下，客户端把自己的数据端口号告诉服务器，建立连接；而被动模式则是由服务器分配端口号，告诉客户端之后再进行数据传输。</p>
<p>FTP协议有两种传输模式，三种数据类型，三种数据结构，这里就不说了。</p>
<p>实现起来本身不难，接受一个请求，再响应即可。原来以为要用状态机，但在允许匿名登录的情况下，基本不需要状态机甚至不需要保存状态，所以难度一下子降低了好多。</p>
<p>但是由于我自己太菜，花了很多时间学习Boost.Asio，写的时候又花了很多时间调BUG，导致整整花了一个礼拜，真是惭愧。</p>
<h2 id="Boost-Asio">Boost.Asio</h2><p>C++的标准库里没有网络编程的部分，而POSIX的那一套又很讨厌，各种宏。恰好Boost里有一个asio，用作网络编程应该还不错。其他一些选择，例如muduo，ACE，暂时没有考虑。</p>
<p>花了一两天时间学习Asio，可能是很久没有接触socket编程的缘故，感觉还是蛮复杂的。它同时支持异步和同步，异步使用proactor模式，看起来很恐怖。目前只学习了同步IO，使用起来相对简单。</p>
<p>一开始比较费解的是它对socket的读写，同步读写分别都有4个接口：read，read_some, read_until，read_at。再加上异步的，async_read, async_read_some, async_read_until, async_read_at。读写加起来有16个接口，对于有选择强迫症的人来说，真是一件很恶心的事情。</p>
<p>这里只谈同步读的接口使用。</p>
<ol>
<li>read：非成员函数，读一定数量的数据到缓冲区，由buffer的大小指定。</li>
<li>read_some：socket的成员函数，读数据到缓冲区，不能制定读取数量。</li>
<li>read_at：非成员函数，同read，不过先skip一段距离。</li>
<li>read_until：非成员函数，读到终止符。</li>
</ol>
<p>前三个函数的缓冲区都是mutable_buffer，可以由数组、vector、字符串之类的东西用buffer函数包装一下得到。而read_until比较特殊，参数是streambuf，属于C++ iostream的一部分，而iostream其实是一个很讨厌的东西，比C-style IO要复杂很多，所以streambuf在这里又增加了接口的使用难度。</p>
<p>小小地总结一下，read_some应该是最底层的，所以也是成员函数，其他的都是wrapper。通常我们进行IO操作会有两种方式，一种是读取指定数量的数据，用read；另一种是基于分隔符，例如HTTP协议，则用read_until，或者自己把它包装一下。</p>
<p>这两种方式和应用层网络协议的设计有关，具体来说就是分帧的方式。像HTTP协议这种的，用CLRF来分帧，在java里面用readLine可以很方便地读取，而read_until则还允许其他的分隔符，增强了可扩展性；另一种方式是基于块的，通常来说这样比较紧凑，效率上有优势，实现的时候一般会在每一块前面加上块大小的标识。不过据云风说，在特殊情况下，即每一块都有类型，不用加上长度标识，用状态机也能解析出来。虽然是这么说，但为了校验之类的事情，应该还是加上长度比较靠谱。这一点也让我想到了编程语言里字符串的实现，像C语言，null-terminate，而把字符串作为first-class的语言，大部分都是在字符串前面加上一个长度标识，既能够快速得到其长度，又能作为分隔标识。</p>
<h2 id="filesystem">filesystem</h2><p>C++标准库同样没有filesystem的支持，依旧在Boost里面。</p>
<p>初看，filesystem的接口设计很奇怪。按照Java的设计，重心在File类，用起来还是比较顺手的。而Boost.filesystem虽然有path这一概念，但它只是字符串的一个包装，提供了路径的计算，大部分功能都用自由函数提供，让我比较好奇。</p>
<p>后来查了一些资料，猛然发现在《Effective C++》里有讲到这一点。当一个函数可以同时实现为成员函数和非成员函数的时候，优先选择非成员函数（自由函数）。原因在于，自由函数的可扩展性较好，用户甚至可以在库的namespace里加上自己定义的自由函数，同时又降低依赖，只在需要的时候“#include”。同时，像algorithm库这种设计精巧的，使用template即可达到以不变应万变的效果，避免了像Scala标准库那样的膨胀。</p>
<p>filesystem里有一个很有意思的东西是directory_iterator，还有一个它的兄弟recursive_directory_iterator，可以和algorithm库配合使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::lambda;</span><br><span class="line"><span class="keyword">typedef</span> directory_iterator d_iter;</span><br><span class="line">sd::for_each(d_iter(<span class="string">"/"</span>), d_iter(), <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; _1 &lt;&lt; <span class="string">'\n'</span>);</span><br></pre></td></tr></table></figure>
<p>这里用到了Boost的lambda库以及占位符，同时用了path的隐式转换，所以代码还是比较简洁的。相比于Scala也是毫不逊色：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/"</span>)).listFiles.foreach(println)</span><br></pre></td></tr></table></figure>
<h2 id="同步_or_异步">同步 or 异步</h2><p>之前玩Node的时候习惯了异步编程，各种异步回调。本来想着用Asio也能够试一下异步，但没想到它的异步不是那么简单，虽然C++14已经有了lambda和参数类型推导的支持，但是还是避免不了异步回调，索性改用多线程同步的做法，看起来还是要简洁一点的。</p>
<p>例如，监听一个端口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Receive</span><span class="params">(ip::tcp::endpoint&amp; ep, Fn fn)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">anon</span><span class="params">([&amp;]()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            io_service ios;</span><br><span class="line">            ip::tcp::<span class="function">acceptor <span class="title">acceptor</span><span class="params">(ios, ep)</span></span>;</span><br><span class="line">            ip::tcp::<span class="function">socket <span class="title">socket</span><span class="params">(ios)</span></span>;</span><br><span class="line">            acceptor.accept(socket);</span><br><span class="line">            fn(socket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"file: %s line %d: %s\n"</span>, __FILE__, __LINE__, e.what());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    anon.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用了标准库里的thread，通过lambda启动了一个线程来监听一个端口，同时在连接之后把socket交给回调，如果有exception，打印文件和行号。还需要detach这个线程，否则terminate的时候会有问题。</p>
<p>回头如果有精力，再去看看Asio的异步编程，也许配合C++14的lambda使用起来能简单一点。</p>
<h2 id="测试">测试</h2><p>现在写东西习惯用测试驱动，包括之前的解释器也用这种方式，虽然要话很多时间写测试，但减少了调试的痛苦，也避免了写了一大堆代码再去测试，去看输入输出。我目前还没有用测试的库，感觉暂时不需要，还是自己手动写Test，用assert来保证结果的正确性。在写一个功能之前，先把测试写好，然后一边写功能，一边测试，通过测试之后基本就能保证功能的正确性，还是蛮爽的。</p>
<p>不过进行网络编程和多线程编程测试起来还是比较麻烦的，为此也想了一些办法来简化测试的难度。例如，如果我需要模拟客户端，发一个数据过去，然后在另一个端口接受：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ip::tcp::endpoint ep(ip::tcp::v4(), 1314);</span><br><span class="line">Receive(ep, [](auto&amp; socket) &#123;</span><br><span class="line">    assert(ReadLine(socket) == "404 not found");</span><br><span class="line">&#125;);</span><br><span class="line">ip::tcp::endpoint remote_ep(ip::tcp::v4(), 8080);</span><br><span class="line">Request(remote_ep, [](auto&amp; socket) &#123;</span><br><span class="line">    WriteLine(socket, "GET / HTTP/1.1");</span><br><span class="line">    WriteLine(socket, "Host: google.com");</span><br><span class="line">    WriteLine(socket, "Connection: close\r\n");</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>是不是有一种NodeJs的即视感？这里也用到了多线程，因为accept会阻塞的。</p>
<h2 id="收获总结">收获总结</h2><ol>
<li>任务驱动是一种很好的学习方式。</li>
<li>了解了一下Boost的一些组件。</li>
<li>复习了网络编程和多线程。</li>
<li>感觉每多写一行代码，对C++的了解都会多一点，看来精通C++指日可待。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>继续我的造轮子之路，花了一个礼拜时间，简单实现了一下FTP协议。自己真是菜啊，居然要写这么久。</p>
<h2 id="FTP协议概述">FTP协议概述</h2><p>FTP协议即文件传输协议，通常用于文件传输。它使用两个连接，一个控制]]>
    </summary>
    
      <category term="Asio" scheme="http://wanghuanming.com/tags/Asio/"/>
    
      <category term="Boost" scheme="http://wanghuanming.com/tags/Boost/"/>
    
      <category term="FTP" scheme="http://wanghuanming.com/tags/FTP/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从解释器到虚拟机]]></title>
    <link href="http://wanghuanming.com/2015/04/write%20a%20simple%20virtual%20machine/"/>
    <id>http://wanghuanming.com/2015/04/write a simple virtual machine/</id>
    <published>2015-04-28T09:33:46.000Z</published>
    <updated>2015-04-28T11:50:57.623Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>上回说到实现一个解释器，从词法分析，到语法分析和语义分析。但事实上，目前的大部分语言并非直接解释执行，而是采用了虚拟机的方式执行的。从实现上讲，在得到语法树之后会转译成字节码，再把字节码放到虚拟机里执行，我们熟悉的大部分语言都是这样做的，例如Java、Python之类。</p>
<p>而编程语言虚拟机又可以分为很多种，按照中间变量的存储方式可以分为基于寄存器的和基于栈的。基于寄存器的虚拟机结构和物理机类似，有多个虚拟的寄存器，起到计算、存储的目的。而基于栈的虚拟机，则不使用虚拟寄存器，直接使用栈作为求值模型。记得我们之前在计算一个像“1+2<em>3-(4+5)</em>6”这样的算数表达式的时候，就是使用了栈这一结构。而与此同时，实现函数调用又离不开栈这一模型，因此用栈来实现计算模型是再适合不过的了。</p>
<p>我这里实现的虚拟机是基于栈的，因为编程实现比较简单，而基于寄存器的还要考虑寄存器分配之类的问题，暂时不在我的知识范畴之内。</p>
<h1 id="指令集">指令集</h1><p>实现一个虚拟机的首要工作是设计一个指令集，或者说是字节码，这是连接语法树和虚拟机的桥梁。在这里我设计了一个很简单的指令集，能够满足简单的计算功能。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>, <span class="keyword">pop</span>, <span class="keyword">mov</span>, load, alloc, <span class="keyword">add</span>, <span class="keyword">sub</span>, <span class="keyword">mul</span>, <span class="keyword">div</span>, mod, <span class="keyword">call</span>, <span class="keyword">jmp</span>, <span class="keyword">ret</span>, ifjmp</span><br></pre></td></tr></table></figure>
<p>这里的指令都只有一个参数，例如push，“push 1”即把1压栈。其他一些指令都可以故名思议。而一些算数操作，add，sub之类的，都是针对的栈顶的两个元素，所以不需要地址。</p>
<p>这样的几个简单指令如何完成一些复杂的操作呢？简单地举几个例子：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量声明：alloc <span class="number">4</span></span><br><span class="line">表达式计算：<span class="keyword">push</span> <span class="number">1</span>, <span class="keyword">push</span> <span class="number">2</span>, <span class="keyword">add</span></span><br><span class="line">函数调用：<span class="keyword">push</span> <span class="number">1</span>, <span class="keyword">push</span> pc_, <span class="keyword">call</span> print</span><br></pre></td></tr></table></figure>
<p>当然，我这个指令集并不是完备的，毕竟别人家的虚拟机都有上百条指令的。</p>
<h1 id="字节码">字节码</h1><p>有了指令集之后，还需要一种存储和表示指令的结构，即字节码。这里的指令很少，4个二进制位其实就能够表示。所以，如果用4个字节来表示一条指令，前面4位可以表示操作类型，而后面的二进制位就能表示地址或者值了。我在实现的时候采用了更简单的方式，用8个字节即C++ 里的long long来表示一条指令，前面4个字节表示操作，后面4个字节表示地址。</p>
<p>有了字节码，我们可以先写一个持久化字节码的模块，即如何把字节码保存到文件，以及从文件提取字节码。原先我考虑转换成JSON表示再直接序列化后存储的，不过后来发现用文本序列化也是很方便的。</p>
<h1 id="语法树到字节码">语法树到字节码</h1><p>从语法树到字节码的过程其实和解释执行很类似，都是判断语法树的类型，然后分类进行求值，只不过这里只转换成字节码而没有进行求值的操作。</p>
<p>举例来说，如果我们要计算“1 + 2 * 3”，鉴于它是以语法树的形式存储的，我们需要进行后序遍历来对它进行求值。转换成的指令如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">mul</span></span><br><span class="line"><span class="keyword">add</span></span><br></pre></td></tr></table></figure>
<p>后续遍历的过程可以写成递归或者非递归的，递归相对简单，非递归相对高效。写到这里我发现了一件很愚蠢的事情，表达式的转换过程如下“中缀表达式 =&gt; 后缀表达式 =&gt; 语法树 =&gt; 指令”，而从后缀表达式其实可以直接得到相应的指令的，也就是说中间的语法树是多余的。我也试着把表达式的语法树之间改成链表，但最终发现会造成语法树结构的不一致性，即“1 + abs(-2)”，这个表达式中有一个函数调用，把表达式改成链表又该如何处理这个函数调用呢，这是一个问题。所以最后还是采用了递归后序遍历的方式来生成指令。</p>
<p>表达式的转码比较简单，花了我更多时间的是函数调用。</p>
<p>在机器语言或者汇编语言中，进行函数调用无非是先把参数压栈，再压入返回地址（即下一条指令），jmp到相应的地址。但我写的时候却发现，函数返回却会遇到问题，我原本是仅仅用了一个栈来计算指令的，这样的结果就是找不到返回地址。所以，帧指针还是需要的，即需要用一个变量来保存函数的起始位置（栈上的位置），使得能够根据它来计算返回地址，以及变量地址的查找。之前学汇编的时候最大的一个疑惑是，如何能够定位到一个变量的地址？即如果有三个变量“a，b，c”，在汇编里会看到它用相对于esp的位置来定位变量，但这个相对距离是如何得到的，我不得而知。</p>
<p>自己实现的时候发现这么一种方法，即在指令转换的时候也用一个栈，至少是模型上的栈。在每一个代码块里，都实例化这么一个栈，如果分配一个变量，相应地改变栈顶的位置，同时把这个变量的名字和相对位置记录下来。这样做的结果是什么？这个栈其实对应了汇编中的“一帧”，相对位置其实也是变量和帧指针的相对位置。这样一来就能轻松地定位到变量了。不过全局变量，或者在作用域之外的变量，用这种方式并不能定位到，还需要其他的方法。</p>
<h1 id="虚拟机">虚拟机</h1><p>虚拟机从概念上看很高端，其实原理很简单，不过可玩性也很高，所以简单的虚拟机和复杂的虚拟机的差距其实就跟人跟蚂蚁的差距那么大。这里只实现一个蚂蚁虚拟机。</p>
<p>我们的蚂蚁虚拟机要实现的功能是什么呢，就是读入一条指令，然后执行。再读，再执行。简单地不能再简单了。</p>
<p>因为是基于栈的，所以最好自己先实现一个栈（STL的栈不能随机访问），能够push、pop、top、top2就差不多了。《CSAPP》告诉我们，指令的执行过程可以概括为：取指、译码、执行，访存，写回，更新PC。虚拟机的执行流程也大抵如是。读入一条指令，用一个switch-case来对指令进行分类，然后根据相应的指令去执行操作，这期中可能还要定位变量什么的，最后更新一下PC（程序计数器）就可以了。</p>
<p>简单地说就是这样，不过我自己实现的时候遇到一些坑，还有一部分没有走出来，等我想出解决方案之后再说。</p>
<h1 id="总结">总结</h1><p>从解释器到虚拟机的转换大概就是这样。看起来很简单，但是有更多的细节要考虑，而很多地方其实我还没有想到一个很好的解决方案。回头再看看Lua的实现，相信会有所启发。同时在此过程中也遇到了类似内存管理的一些细节问题，凸显了自己薄弱的编程基本功，看来自己还是很菜的，还是需要好好学习，不能像轮子哥一样整天刷知乎。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>上回说到实现一个解释器，从词法分析，到语法分析和语义分析。但事实上，目前的大部分语言并非直接解释执行，而是采用了虚拟机的方式执行的。从实现上讲，在得到语法树之后会转译成字节码，再把字节码放到虚拟机里执行，我们熟悉的大部分语言都是这样做的]]>
    </summary>
    
      <category term="编译原理" scheme="http://wanghuanming.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="虚拟机" scheme="http://wanghuanming.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="解释器" scheme="http://wanghuanming.com/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    
      <category term="Code" scheme="http://wanghuanming.com/categories/Code/"/>
    
  </entry>
  
</feed>